// Code generated by cli-gen. DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strings"

	"github.com/spf13/cobra"
)

func new{{toPascal .Name}}Cmd(client *Client) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "{{.Name}}",
		Short: {{quote .Short}},
	}

{{- $groupName := .Name}}

{{- /* Collect unique subcommand names */ -}}
{{- $subcommands := uniqueSubcommands .Commands}}

{{- /* Create subcommands for each command_path */ -}}
{{- range $sub := $subcommands}}

	{{toCamel $sub}}Cmd := &cobra.Command{
		Use:   "{{$sub}}",
		Short: "Manage {{$sub}}",
	}
	cmd.AddCommand({{toCamel $sub}}Cmd)
{{- end}}

{{- /* Now add each command to the right parent */ -}}
{{- range $cmd := .Commands}}

	// {{$cmd.OperationID}}
	{
		{{- /* Build the command */}}
		c := &cobra.Command{
			Use:   {{quote $cmd.Use}},
			Short: {{quote $cmd.Short}},
			{{- if $cmd.Long}}
			Long:  {{quote $cmd.Long}},
			{{- end}}
			{{- if $cmd.Examples}}
			Example: {{quote (join $cmd.Examples "\n")}},
			{{- end}}
			{{- if $cmd.PositionalArgs}}
			Args: cobra.ExactArgs({{len $cmd.PositionalArgs}}),
			{{- end}}
			RunE: func(cmd *cobra.Command, args []string) error {
				{{- if not (isNoContent $cmd.Response.Pattern)}}
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				{{- end}}
				{{- if $cmd.Confirm}}
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				{{- end}}

				{{- /* Build URL path with param substitution */}}
				urlPath := "{{$cmd.URLPath}}"
				{{- range $i, $pa := $cmd.PositionalArgs}}
				{{- range $cmd.PathParams}}
				{{- if eq .Name $pa}}
				urlPath = strings.Replace(urlPath, "{{"{"}}{{.Name}}{{"}"}}", args[{{$i}}], 1)
				{{- end}}
				{{- end}}
				{{- end}}
				{{- /* Non-positional path params from flags */}}
				{{- range $cmd.PathParams}}
				{{- $isPositional := false}}
				{{- range $cmd.PositionalArgs}}{{- if eq . $cmd.OperationID}}{{$isPositional = true}}{{end}}{{end}}
				{{- end}}

				{{- /* Build query params */}}
				query := url.Values{}
				{{- range $cmd.Flags}}
				{{- if not .IsBody}}
				{{- if eq .CobraType "String"}}
				if cmd.Flags().Changed("{{.Name}}") {
					v, _ := cmd.Flags().GetString("{{.Name}}")
					query.Set("{{.FieldName}}", v)
				}
				{{- else if eq .CobraType "Int64"}}
				if cmd.Flags().Changed("{{.Name}}") {
					v, _ := cmd.Flags().GetInt64("{{.Name}}")
					query.Set("{{.FieldName}}", fmt.Sprintf("%d", v))
				}
				{{- else if eq .CobraType "Bool"}}
				if cmd.Flags().Changed("{{.Name}}") {
					v, _ := cmd.Flags().GetBool("{{.Name}}")
					query.Set("{{.FieldName}}", fmt.Sprintf("%t", v))
				}
				{{- end}}
				{{- end}}
				{{- end}}

				{{- if $cmd.HasBody}}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					{{- range $cmd.Flags}}
					{{- if and .IsBody (ne .FieldName "__json__")}}
					{{- if eq .CobraType "String"}}
					if cmd.Flags().Changed("{{.Name}}") {
						v, _ := cmd.Flags().GetString("{{.Name}}")
						{{- if contains .FieldName "."}}
						// Nested field: {{.FieldName}}
						parts := strings.SplitN("{{.FieldName}}", ".", 2)
						if m[parts[0]] == nil {
							m[parts[0]] = map[string]interface{}{}
						}
						m[parts[0]].(map[string]interface{})[parts[1]] = v
						{{- else}}
						m["{{.FieldName}}"] = v
						{{- end}}
					}
					{{- else if eq .CobraType "Int64"}}
					if cmd.Flags().Changed("{{.Name}}") {
						v, _ := cmd.Flags().GetInt64("{{.Name}}")
						{{- if contains .FieldName "."}}
						parts := strings.SplitN("{{.FieldName}}", ".", 2)
						if m[parts[0]] == nil {
							m[parts[0]] = map[string]interface{}{}
						}
						m[parts[0]].(map[string]interface{})[parts[1]] = v
						{{- else}}
						m["{{.FieldName}}"] = v
						{{- end}}
					}
					{{- else if eq .CobraType "Bool"}}
					if cmd.Flags().Changed("{{.Name}}") {
						v, _ := cmd.Flags().GetBool("{{.Name}}")
						{{- if contains .FieldName "."}}
						parts := strings.SplitN("{{.FieldName}}", ".", 2)
						if m[parts[0]] == nil {
							m[parts[0]] = map[string]interface{}{}
						}
						m[parts[0]].(map[string]interface{})[parts[1]] = v
						{{- else}}
						m["{{.FieldName}}"] = v
						{{- end}}
					}
					{{- else if eq .CobraType "StringSlice"}}
					if cmd.Flags().Changed("{{.Name}}") {
						v, _ := cmd.Flags().GetStringSlice("{{.Name}}")
						{{- if .IsCompound}}
						// Compound flag: parse "{{join .CompoundFields .CompoundSep}}" format
						var items []map[string]interface{}
						for _, item := range v {
							parts := strings.SplitN(item, "{{.CompoundSep}}", {{len .CompoundFields}})
							if len(parts) != {{len .CompoundFields}} {
								return fmt.Errorf("invalid format for --{{.Name}}: expected {{join .CompoundFields .CompoundSep}}")
							}
							entry := map[string]interface{}{}
							{{- range $fi, $field := .CompoundFields}}
							entry["{{$field}}"] = parts[{{$fi}}]
							{{- end}}
							items = append(items, entry)
						}
						m["{{.FieldName}}"] = items
						{{- else}}
						m["{{.FieldName}}"] = v
						{{- end}}
					}
					{{- else if eq .CobraType "StringToString"}}
					if cmd.Flags().Changed("{{.Name}}") {
						v, _ := cmd.Flags().GetStringToString("{{.Name}}")
						m["{{.FieldName}}"] = v
					}
					{{- end}}
					{{- end}}
					{{- end}}
					{{- /* Add positional args to body if they are body fields */}}
					{{- range $i, $pa := $cmd.PositionalArgs}}
					{{- range $cmd.BodyFields}}
					{{- if eq .Name $pa}}
					m["{{.Name}}"] = args[{{$i}}]
					{{- end}}
					{{- end}}
					{{- end}}
					if len(m) > 0 {
						body = m
					}
				}
				{{- end}}

				// Execute request
				resp, err := client.Do("{{$cmd.Method}}", urlPath, query, {{if $cmd.HasBody}}body{{else}}nil{{end}})
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}

				{{- if isNoContent $cmd.Response.Pattern}}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
				{{- else}}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					{{- if isPaginatedList $cmd.Response.Pattern}}
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{ {{- range $i, $col := $cmd.Response.TableColumns}}{{if $i}}, {{end}}{{quote $col}}{{end}} }
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
					{{- else if isSingleResource $cmd.Response.Pattern}}
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
					{{- else}}
					// Custom result: default to JSON
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
					{{- end}}
				}
				return nil
				{{- end}}
			},
		}

		{{- /* Register flags */}}
		{{- range $cmd.Flags}}
		{{- if eq .CobraType "String"}}
		c.Flags().String{{if .Short}}P{{end}}("{{.Name}}"{{if .Short}}, "{{.Short}}"{{end}}, "{{defaultValue .}}", {{quote .Usage}})
		{{- else if eq .CobraType "Int64"}}
		c.Flags().Int64{{if .Short}}P{{end}}("{{.Name}}"{{if .Short}}, "{{.Short}}"{{end}}, {{defaultValue .}}, {{quote .Usage}})
		{{- else if eq .CobraType "Bool"}}
		c.Flags().Bool{{if .Short}}P{{end}}("{{.Name}}"{{if .Short}}, "{{.Short}}"{{end}}, {{defaultValue .}}, {{quote .Usage}})
		{{- else if eq .CobraType "StringSlice"}}
		c.Flags().StringSlice("{{.Name}}", nil, {{quote .Usage}})
		{{- else if eq .CobraType "StringToString"}}
		c.Flags().StringToString("{{.Name}}", nil, {{quote .Usage}})
		{{- else if eq .CobraType "Float64"}}
		c.Flags().Float64("{{.Name}}", {{defaultValue .}}, {{quote .Usage}})
		{{- end}}
		{{- if .Required}}
		_ = c.MarkFlagRequired("{{.Name}}")
		{{- end}}
		{{- end}}

		{{- if $cmd.Confirm}}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")
		{{- end}}

		// Apply overrides
		if fn, ok := runOverrides["{{$cmd.OperationID}}"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["{{$cmd.OperationID}}"]; ok {
			fn(c)
		}

		{{- if $cmd.CommandPath}}
		{{toCamel (index $cmd.CommandPath 0)}}Cmd.AddCommand(c)
		{{- else}}
		cmd.AddCommand(c)
		{{- end}}
	}
{{- end}}

	return cmd
}
