// Code generated by cli-gen. DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"strings"

	"golang.org/x/term"
)

// OutputFormat represents the output format.
type OutputFormat string

const (
	OutputTable OutputFormat = "table"
	OutputJSON  OutputFormat = "json"
	OutputCSV   OutputFormat = "csv"
)

// GetTerminalWidth returns the terminal width or a default.
func GetTerminalWidth() int {
	if w, _, err := term.GetSize(int(os.Stdout.Fd())); err == nil && w > 0 {
		return w
	}
	return 120
}

// IsTTY returns true if stdout is a terminal.
func IsTTY() bool {
	return term.IsTerminal(int(os.Stdout.Fd()))
}

// PrintTable renders tabular data to stdout using a simple columnar layout.
func PrintTable(w io.Writer, columns []string, rows [][]string) {
	if len(columns) == 0 {
		return
	}

	// Compute column widths
	widths := make([]int, len(columns))
	for i, col := range columns {
		widths[i] = len(col)
	}
	for _, row := range rows {
		for i := 0; i < len(row) && i < len(widths); i++ {
			if len(row[i]) > widths[i] {
				widths[i] = len(row[i])
			}
		}
	}

	// Truncate if TTY
	if IsTTY() {
		maxWidth := GetTerminalWidth()
		colWidth := maxWidth / maxInt(len(columns), 1)
		if colWidth < 10 {
			colWidth = 10
		}
		for i := range widths {
			if widths[i] > colWidth {
				widths[i] = colWidth
			}
		}
		for i := range rows {
			for j := range rows[i] {
				if j < len(widths) && len(rows[i][j]) > widths[j] {
					rows[i][j] = rows[i][j][:widths[j]-3] + "..."
				}
			}
		}
	}

	// Print header
	for i, col := range columns {
		if i > 0 {
			fmt.Fprint(w, "  ")
		}
		fmt.Fprintf(w, "%-*s", widths[i], strings.ToUpper(col))
	}
	fmt.Fprintln(w)

	// Print rows
	for _, row := range rows {
		for i := 0; i < len(columns); i++ {
			if i > 0 {
				fmt.Fprint(w, "  ")
			}
			val := ""
			if i < len(row) {
				val = row[i]
			}
			fmt.Fprintf(w, "%-*s", widths[i], val)
		}
		fmt.Fprintln(w)
	}
}

// PrintJSON outputs data as formatted JSON.
func PrintJSON(w io.Writer, data interface{}) error {
	enc := json.NewEncoder(w)
	enc.SetIndent("", "  ")
	return enc.Encode(data)
}

// PrintDetail prints a single resource as key-value pairs.
func PrintDetail(w io.Writer, fields map[string]interface{}) {
	maxKeyLen := 0
	keys := make([]string, 0, len(fields))
	for k := range fields {
		keys = append(keys, k)
		if len(k) > maxKeyLen {
			maxKeyLen = len(k)
		}
	}
	// Sort keys for deterministic output
	sortStrings(keys)
	for _, k := range keys {
		v := fields[k]
		padding := strings.Repeat(" ", maxKeyLen-len(k))
		fmt.Fprintf(w, "%s:%s  %s\n", k, padding, FormatValue(v))
	}
}

// ConfirmPrompt asks the user for confirmation.
func ConfirmPrompt(message string) bool {
	fmt.Fprintf(os.Stderr, "%s [y/N]: ", message)
	var response string
	fmt.Scanln(&response)
	response = strings.ToLower(strings.TrimSpace(response))
	return response == "y" || response == "yes"
}

// ExtractField extracts a field from a generic map.
func ExtractField(data map[string]interface{}, field string) string {
	v, ok := data[field]
	if !ok || v == nil {
		return ""
	}
	return FormatValue(v)
}

// FormatValue formats a value for human-readable CLI display.
// It avoids Go-internal representations like <nil>, map[...], and [a b].
func FormatValue(v interface{}) string {
	if v == nil {
		return ""
	}
	switch val := v.(type) {
	case string:
		return val
	case float64:
		if val == float64(int64(val)) {
			return fmt.Sprintf("%d", int64(val))
		}
		return fmt.Sprintf("%g", val)
	case bool:
		return fmt.Sprintf("%t", val)
	case map[string]interface{}:
		b, _ := json.Marshal(val)
		return string(b)
	case []interface{}:
		b, _ := json.Marshal(val)
		return string(b)
	default:
		return fmt.Sprintf("%v", v)
	}
}

// ExtractRows extracts table rows from a paginated response.
func ExtractRows(data map[string]interface{}, columns []string) [][]string {
	items, ok := data["data"].([]interface{})
	if !ok {
		return nil
	}
	rows := make([][]string, 0, len(items))
	for _, item := range items {
		m, ok := item.(map[string]interface{})
		if !ok {
			continue
		}
		row := make([]string, len(columns))
		for i, col := range columns {
			row[i] = ExtractField(m, col)
		}
		rows = append(rows, row)
	}
	return rows
}

func sortStrings(s []string) {
	for i := 1; i < len(s); i++ {
		for j := i; j > 0 && s[j] < s[j-1]; j-- {
			s[j], s[j-1] = s[j-1], s[j]
		}
	}
}

func maxInt(a, b int) int {
	if a > b {
		return a
	}
	return b
}
