// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: compute_endpoints.sql

package dbstore

import (
	"context"
	"database/sql"
)

const countAssignmentsForEndpoint = `-- name: CountAssignmentsForEndpoint :one
SELECT COUNT(*) FROM compute_assignments WHERE endpoint_id = ?
`

func (q *Queries) CountAssignmentsForEndpoint(ctx context.Context, endpointID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAssignmentsForEndpoint, endpointID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countComputeEndpoints = `-- name: CountComputeEndpoints :one
SELECT COUNT(*) FROM compute_endpoints
`

func (q *Queries) CountComputeEndpoints(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countComputeEndpoints)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createComputeAssignment = `-- name: CreateComputeAssignment :one
INSERT INTO compute_assignments (
    id, principal_id, principal_type, endpoint_id, is_default, fallback_local
) VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, principal_id, principal_type, endpoint_id, is_default, fallback_local, created_at
`

type CreateComputeAssignmentParams struct {
	ID            string
	PrincipalID   string
	PrincipalType string
	EndpointID    string
	IsDefault     int64
	FallbackLocal int64
}

func (q *Queries) CreateComputeAssignment(ctx context.Context, arg CreateComputeAssignmentParams) (ComputeAssignment, error) {
	row := q.db.QueryRowContext(ctx, createComputeAssignment,
		arg.ID,
		arg.PrincipalID,
		arg.PrincipalType,
		arg.EndpointID,
		arg.IsDefault,
		arg.FallbackLocal,
	)
	var i ComputeAssignment
	err := row.Scan(
		&i.ID,
		&i.PrincipalID,
		&i.PrincipalType,
		&i.EndpointID,
		&i.IsDefault,
		&i.FallbackLocal,
		&i.CreatedAt,
	)
	return i, err
}

const createComputeEndpoint = `-- name: CreateComputeEndpoint :one
INSERT INTO compute_endpoints (
    id, external_id, name, url, type, status, size, max_memory_gb, auth_token, owner
) VALUES (?, ?, ?, ?, ?, 'INACTIVE', ?, ?, ?, ?)
RETURNING id, external_id, name, url, type, status, size, max_memory_gb, auth_token, owner, created_at, updated_at
`

type CreateComputeEndpointParams struct {
	ID          string
	ExternalID  string
	Name        string
	Url         string
	Type        string
	Size        string
	MaxMemoryGb sql.NullInt64
	AuthToken   string
	Owner       string
}

func (q *Queries) CreateComputeEndpoint(ctx context.Context, arg CreateComputeEndpointParams) (ComputeEndpoint, error) {
	row := q.db.QueryRowContext(ctx, createComputeEndpoint,
		arg.ID,
		arg.ExternalID,
		arg.Name,
		arg.Url,
		arg.Type,
		arg.Size,
		arg.MaxMemoryGb,
		arg.AuthToken,
		arg.Owner,
	)
	var i ComputeEndpoint
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Url,
		&i.Type,
		&i.Status,
		&i.Size,
		&i.MaxMemoryGb,
		&i.AuthToken,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteComputeAssignment = `-- name: DeleteComputeAssignment :exec
DELETE FROM compute_assignments WHERE id = ?
`

func (q *Queries) DeleteComputeAssignment(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteComputeAssignment, id)
	return err
}

const deleteComputeEndpoint = `-- name: DeleteComputeEndpoint :exec
DELETE FROM compute_endpoints WHERE id = ?
`

func (q *Queries) DeleteComputeEndpoint(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteComputeEndpoint, id)
	return err
}

const getAssignmentsForPrincipal = `-- name: GetAssignmentsForPrincipal :many
SELECT ce.id, ce.external_id, ce.name, ce.url, ce.type, ce.status, ce.size, ce.max_memory_gb, ce.auth_token, ce.owner, ce.created_at, ce.updated_at
FROM compute_endpoints ce
JOIN compute_assignments ca ON ca.endpoint_id = ce.id
WHERE ca.principal_id = ?
  AND ca.principal_type = ?
ORDER BY ca.is_default DESC, ce.name
`

type GetAssignmentsForPrincipalParams struct {
	PrincipalID   string
	PrincipalType string
}

func (q *Queries) GetAssignmentsForPrincipal(ctx context.Context, arg GetAssignmentsForPrincipalParams) ([]ComputeEndpoint, error) {
	rows, err := q.db.QueryContext(ctx, getAssignmentsForPrincipal, arg.PrincipalID, arg.PrincipalType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ComputeEndpoint
	for rows.Next() {
		var i ComputeEndpoint
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Url,
			&i.Type,
			&i.Status,
			&i.Size,
			&i.MaxMemoryGb,
			&i.AuthToken,
			&i.Owner,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComputeEndpoint = `-- name: GetComputeEndpoint :one
SELECT id, external_id, name, url, type, status, size, max_memory_gb, auth_token, owner, created_at, updated_at FROM compute_endpoints WHERE id = ?
`

func (q *Queries) GetComputeEndpoint(ctx context.Context, id string) (ComputeEndpoint, error) {
	row := q.db.QueryRowContext(ctx, getComputeEndpoint, id)
	var i ComputeEndpoint
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Url,
		&i.Type,
		&i.Status,
		&i.Size,
		&i.MaxMemoryGb,
		&i.AuthToken,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getComputeEndpointByName = `-- name: GetComputeEndpointByName :one
SELECT id, external_id, name, url, type, status, size, max_memory_gb, auth_token, owner, created_at, updated_at FROM compute_endpoints WHERE name = ?
`

func (q *Queries) GetComputeEndpointByName(ctx context.Context, name string) (ComputeEndpoint, error) {
	row := q.db.QueryRowContext(ctx, getComputeEndpointByName, name)
	var i ComputeEndpoint
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Url,
		&i.Type,
		&i.Status,
		&i.Size,
		&i.MaxMemoryGb,
		&i.AuthToken,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDefaultEndpointForPrincipal = `-- name: GetDefaultEndpointForPrincipal :one
SELECT ce.id, ce.external_id, ce.name, ce.url, ce.type, ce.status, ce.size, ce.max_memory_gb, ce.auth_token, ce.owner, ce.created_at, ce.updated_at
FROM compute_endpoints ce
JOIN compute_assignments ca ON ca.endpoint_id = ce.id
WHERE ca.principal_id = ?
  AND ca.principal_type = ?
  AND ca.is_default = 1
  AND ce.status = 'ACTIVE'
LIMIT 1
`

type GetDefaultEndpointForPrincipalParams struct {
	PrincipalID   string
	PrincipalType string
}

func (q *Queries) GetDefaultEndpointForPrincipal(ctx context.Context, arg GetDefaultEndpointForPrincipalParams) (ComputeEndpoint, error) {
	row := q.db.QueryRowContext(ctx, getDefaultEndpointForPrincipal, arg.PrincipalID, arg.PrincipalType)
	var i ComputeEndpoint
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Url,
		&i.Type,
		&i.Status,
		&i.Size,
		&i.MaxMemoryGb,
		&i.AuthToken,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAssignmentsForEndpoint = `-- name: ListAssignmentsForEndpoint :many
SELECT id, principal_id, principal_type, endpoint_id, is_default, fallback_local, created_at FROM compute_assignments WHERE endpoint_id = ? ORDER BY id LIMIT ? OFFSET ?
`

type ListAssignmentsForEndpointParams struct {
	EndpointID string
	Limit      int64
	Offset     int64
}

func (q *Queries) ListAssignmentsForEndpoint(ctx context.Context, arg ListAssignmentsForEndpointParams) ([]ComputeAssignment, error) {
	rows, err := q.db.QueryContext(ctx, listAssignmentsForEndpoint, arg.EndpointID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ComputeAssignment
	for rows.Next() {
		var i ComputeAssignment
		if err := rows.Scan(
			&i.ID,
			&i.PrincipalID,
			&i.PrincipalType,
			&i.EndpointID,
			&i.IsDefault,
			&i.FallbackLocal,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComputeEndpoints = `-- name: ListComputeEndpoints :many
SELECT id, external_id, name, url, type, status, size, max_memory_gb, auth_token, owner, created_at, updated_at FROM compute_endpoints ORDER BY name LIMIT ? OFFSET ?
`

type ListComputeEndpointsParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListComputeEndpoints(ctx context.Context, arg ListComputeEndpointsParams) ([]ComputeEndpoint, error) {
	rows, err := q.db.QueryContext(ctx, listComputeEndpoints, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ComputeEndpoint
	for rows.Next() {
		var i ComputeEndpoint
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Url,
			&i.Type,
			&i.Status,
			&i.Size,
			&i.MaxMemoryGb,
			&i.AuthToken,
			&i.Owner,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveEndpointForPrincipalByName = `-- name: ResolveEndpointForPrincipalByName :one
SELECT ce.id, ce.external_id, ce.name, ce.url, ce.type, ce.status, ce.size, ce.max_memory_gb, ce.auth_token, ce.owner, ce.created_at, ce.updated_at
FROM compute_endpoints ce
JOIN compute_assignments ca ON ca.endpoint_id = ce.id
JOIN principals p ON p.id = ca.principal_id AND ca.principal_type = 'user'
WHERE p.name = ?
  AND ca.is_default = 1
  AND ce.status = 'ACTIVE'
LIMIT 1
`

func (q *Queries) ResolveEndpointForPrincipalByName(ctx context.Context, name string) (ComputeEndpoint, error) {
	row := q.db.QueryRowContext(ctx, resolveEndpointForPrincipalByName, name)
	var i ComputeEndpoint
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Url,
		&i.Type,
		&i.Status,
		&i.Size,
		&i.MaxMemoryGb,
		&i.AuthToken,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateComputeEndpoint = `-- name: UpdateComputeEndpoint :exec
UPDATE compute_endpoints
SET url = COALESCE(?, url),
    size = COALESCE(?, size),
    max_memory_gb = COALESCE(?, max_memory_gb),
    auth_token = COALESCE(?, auth_token),
    updated_at = datetime('now')
WHERE id = ?
`

type UpdateComputeEndpointParams struct {
	Url         string
	Size        string
	MaxMemoryGb sql.NullInt64
	AuthToken   string
	ID          string
}

func (q *Queries) UpdateComputeEndpoint(ctx context.Context, arg UpdateComputeEndpointParams) error {
	_, err := q.db.ExecContext(ctx, updateComputeEndpoint,
		arg.Url,
		arg.Size,
		arg.MaxMemoryGb,
		arg.AuthToken,
		arg.ID,
	)
	return err
}

const updateComputeEndpointStatus = `-- name: UpdateComputeEndpointStatus :exec
UPDATE compute_endpoints
SET status = ?,
    updated_at = datetime('now')
WHERE id = ?
`

type UpdateComputeEndpointStatusParams struct {
	Status string
	ID     string
}

func (q *Queries) UpdateComputeEndpointStatus(ctx context.Context, arg UpdateComputeEndpointStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateComputeEndpointStatus, arg.Status, arg.ID)
	return err
}
