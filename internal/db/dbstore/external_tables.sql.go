// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: external_tables.sql

package dbstore

import (
	"context"
)

const countExternalTables = `-- name: CountExternalTables :one
SELECT COUNT(*) FROM external_tables
WHERE schema_name = ? AND deleted_at IS NULL
`

func (q *Queries) CountExternalTables(ctx context.Context, schemaName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countExternalTables, schemaName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExternalTable = `-- name: CreateExternalTable :one
INSERT INTO external_tables (id, schema_name, table_name, file_format, source_path, location_name, comment, owner, catalog_name)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, schema_name, table_name, file_format, source_path, location_name, comment, owner, created_at, updated_at, deleted_at, catalog_name
`

type CreateExternalTableParams struct {
	ID           string
	SchemaName   string
	TableName    string
	FileFormat   string
	SourcePath   string
	LocationName string
	Comment      string
	Owner        string
	CatalogName  string
}

func (q *Queries) CreateExternalTable(ctx context.Context, arg CreateExternalTableParams) (ExternalTable, error) {
	row := q.db.QueryRowContext(ctx, createExternalTable,
		arg.ID,
		arg.SchemaName,
		arg.TableName,
		arg.FileFormat,
		arg.SourcePath,
		arg.LocationName,
		arg.Comment,
		arg.Owner,
		arg.CatalogName,
	)
	var i ExternalTable
	err := row.Scan(
		&i.ID,
		&i.SchemaName,
		&i.TableName,
		&i.FileFormat,
		&i.SourcePath,
		&i.LocationName,
		&i.Comment,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CatalogName,
	)
	return i, err
}

const deleteExternalTableColumns = `-- name: DeleteExternalTableColumns :exec
DELETE FROM external_table_columns
WHERE external_table_id = ?
`

func (q *Queries) DeleteExternalTableColumns(ctx context.Context, externalTableID string) error {
	_, err := q.db.ExecContext(ctx, deleteExternalTableColumns, externalTableID)
	return err
}

const getExternalTableByID = `-- name: GetExternalTableByID :one
SELECT id, schema_name, table_name, file_format, source_path, location_name, comment, owner, created_at, updated_at, deleted_at, catalog_name FROM external_tables
WHERE id = ? AND deleted_at IS NULL
`

func (q *Queries) GetExternalTableByID(ctx context.Context, id string) (ExternalTable, error) {
	row := q.db.QueryRowContext(ctx, getExternalTableByID, id)
	var i ExternalTable
	err := row.Scan(
		&i.ID,
		&i.SchemaName,
		&i.TableName,
		&i.FileFormat,
		&i.SourcePath,
		&i.LocationName,
		&i.Comment,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CatalogName,
	)
	return i, err
}

const getExternalTableByName = `-- name: GetExternalTableByName :one
SELECT id, schema_name, table_name, file_format, source_path, location_name, comment, owner, created_at, updated_at, deleted_at, catalog_name FROM external_tables
WHERE schema_name = ? AND table_name = ? AND deleted_at IS NULL
`

type GetExternalTableByNameParams struct {
	SchemaName string
	TableName  string
}

func (q *Queries) GetExternalTableByName(ctx context.Context, arg GetExternalTableByNameParams) (ExternalTable, error) {
	row := q.db.QueryRowContext(ctx, getExternalTableByName, arg.SchemaName, arg.TableName)
	var i ExternalTable
	err := row.Scan(
		&i.ID,
		&i.SchemaName,
		&i.TableName,
		&i.FileFormat,
		&i.SourcePath,
		&i.LocationName,
		&i.Comment,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CatalogName,
	)
	return i, err
}

const getExternalTableByTableName = `-- name: GetExternalTableByTableName :one
SELECT id, schema_name, table_name, file_format, source_path, location_name, comment, owner, created_at, updated_at, deleted_at, catalog_name FROM external_tables
WHERE table_name = ? AND deleted_at IS NULL
`

func (q *Queries) GetExternalTableByTableName(ctx context.Context, tableName string) (ExternalTable, error) {
	row := q.db.QueryRowContext(ctx, getExternalTableByTableName, tableName)
	var i ExternalTable
	err := row.Scan(
		&i.ID,
		&i.SchemaName,
		&i.TableName,
		&i.FileFormat,
		&i.SourcePath,
		&i.LocationName,
		&i.Comment,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CatalogName,
	)
	return i, err
}

const insertExternalTableColumn = `-- name: InsertExternalTableColumn :exec
INSERT INTO external_table_columns (id, external_table_id, column_name, column_type, position)
VALUES (?, ?, ?, ?, ?)
`

type InsertExternalTableColumnParams struct {
	ID              string
	ExternalTableID string
	ColumnName      string
	ColumnType      string
	Position        int64
}

func (q *Queries) InsertExternalTableColumn(ctx context.Context, arg InsertExternalTableColumnParams) error {
	_, err := q.db.ExecContext(ctx, insertExternalTableColumn,
		arg.ID,
		arg.ExternalTableID,
		arg.ColumnName,
		arg.ColumnType,
		arg.Position,
	)
	return err
}

const listAllExternalTables = `-- name: ListAllExternalTables :many
SELECT id, schema_name, table_name, file_format, source_path, location_name, comment, owner, created_at, updated_at, deleted_at, catalog_name FROM external_tables
WHERE deleted_at IS NULL
`

func (q *Queries) ListAllExternalTables(ctx context.Context) ([]ExternalTable, error) {
	rows, err := q.db.QueryContext(ctx, listAllExternalTables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExternalTable
	for rows.Next() {
		var i ExternalTable
		if err := rows.Scan(
			&i.ID,
			&i.SchemaName,
			&i.TableName,
			&i.FileFormat,
			&i.SourcePath,
			&i.LocationName,
			&i.Comment,
			&i.Owner,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CatalogName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExternalTableColumns = `-- name: ListExternalTableColumns :many
SELECT id, external_table_id, column_name, column_type, position FROM external_table_columns
WHERE external_table_id = ?
ORDER BY position
`

func (q *Queries) ListExternalTableColumns(ctx context.Context, externalTableID string) ([]ExternalTableColumn, error) {
	rows, err := q.db.QueryContext(ctx, listExternalTableColumns, externalTableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExternalTableColumn
	for rows.Next() {
		var i ExternalTableColumn
		if err := rows.Scan(
			&i.ID,
			&i.ExternalTableID,
			&i.ColumnName,
			&i.ColumnType,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExternalTables = `-- name: ListExternalTables :many
SELECT id, schema_name, table_name, file_format, source_path, location_name, comment, owner, created_at, updated_at, deleted_at, catalog_name FROM external_tables
WHERE schema_name = ? AND deleted_at IS NULL
ORDER BY table_name
LIMIT ? OFFSET ?
`

type ListExternalTablesParams struct {
	SchemaName string
	Limit      int64
	Offset     int64
}

func (q *Queries) ListExternalTables(ctx context.Context, arg ListExternalTablesParams) ([]ExternalTable, error) {
	rows, err := q.db.QueryContext(ctx, listExternalTables, arg.SchemaName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExternalTable
	for rows.Next() {
		var i ExternalTable
		if err := rows.Scan(
			&i.ID,
			&i.SchemaName,
			&i.TableName,
			&i.FileFormat,
			&i.SourcePath,
			&i.LocationName,
			&i.Comment,
			&i.Owner,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CatalogName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteExternalTable = `-- name: SoftDeleteExternalTable :exec
UPDATE external_tables SET deleted_at = datetime('now')
WHERE schema_name = ? AND table_name = ? AND deleted_at IS NULL
`

type SoftDeleteExternalTableParams struct {
	SchemaName string
	TableName  string
}

func (q *Queries) SoftDeleteExternalTable(ctx context.Context, arg SoftDeleteExternalTableParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteExternalTable, arg.SchemaName, arg.TableName)
	return err
}

const softDeleteExternalTablesBySchema = `-- name: SoftDeleteExternalTablesBySchema :exec
UPDATE external_tables SET deleted_at = datetime('now')
WHERE schema_name = ? AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteExternalTablesBySchema(ctx context.Context, schemaName string) error {
	_, err := q.db.ExecContext(ctx, softDeleteExternalTablesBySchema, schemaName)
	return err
}

const updateExternalTable = `-- name: UpdateExternalTable :exec
UPDATE external_tables
SET comment = CASE WHEN ?1 = 1 THEN ?2 ELSE comment END,
    owner = CASE WHEN ?3 = 1 THEN ?4 ELSE owner END,
    updated_at = datetime('now')
WHERE schema_name = ?5 AND table_name = ?6 AND deleted_at IS NULL
`

type UpdateExternalTableParams struct {
	SetComment interface{}
	Comment    string
	SetOwner   interface{}
	Owner      string
	SchemaName string
	TableName  string
}

func (q *Queries) UpdateExternalTable(ctx context.Context, arg UpdateExternalTableParams) error {
	_, err := q.db.ExecContext(ctx, updateExternalTable,
		arg.SetComment,
		arg.Comment,
		arg.SetOwner,
		arg.Owner,
		arg.SchemaName,
		arg.TableName,
	)
	return err
}
