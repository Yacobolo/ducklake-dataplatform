// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notebooks.sql

package dbstore

import (
	"context"
	"database/sql"
)

const countNotebooks = `-- name: CountNotebooks :one
SELECT COUNT(*) FROM notebooks
WHERE (?1 IS NULL OR owner = ?1)
`

func (q *Queries) CountNotebooks(ctx context.Context, owner interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotebooks, owner)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCell = `-- name: CreateCell :one
INSERT INTO cells (id, notebook_id, cell_type, content, position)
VALUES (?, ?, ?, ?, ?)
RETURNING id, notebook_id, cell_type, content, position, last_result, created_at, updated_at
`

type CreateCellParams struct {
	ID         string
	NotebookID string
	CellType   string
	Content    string
	Position   int64
}

func (q *Queries) CreateCell(ctx context.Context, arg CreateCellParams) (Cell, error) {
	row := q.db.QueryRowContext(ctx, createCell,
		arg.ID,
		arg.NotebookID,
		arg.CellType,
		arg.Content,
		arg.Position,
	)
	var i Cell
	err := row.Scan(
		&i.ID,
		&i.NotebookID,
		&i.CellType,
		&i.Content,
		&i.Position,
		&i.LastResult,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNotebook = `-- name: CreateNotebook :one
INSERT INTO notebooks (id, name, description, owner)
VALUES (?, ?, ?, ?)
RETURNING id, name, description, owner, created_at, updated_at, git_repo_id, git_path
`

type CreateNotebookParams struct {
	ID          string
	Name        string
	Description sql.NullString
	Owner       string
}

func (q *Queries) CreateNotebook(ctx context.Context, arg CreateNotebookParams) (Notebook, error) {
	row := q.db.QueryRowContext(ctx, createNotebook,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Owner,
	)
	var i Notebook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GitRepoID,
		&i.GitPath,
	)
	return i, err
}

const deleteCell = `-- name: DeleteCell :exec
DELETE FROM cells WHERE id = ?
`

func (q *Queries) DeleteCell(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteCell, id)
	return err
}

const deleteNotebook = `-- name: DeleteNotebook :exec
DELETE FROM notebooks WHERE id = ?
`

func (q *Queries) DeleteNotebook(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteNotebook, id)
	return err
}

const getCell = `-- name: GetCell :one
SELECT id, notebook_id, cell_type, content, position, last_result, created_at, updated_at FROM cells WHERE id = ?
`

func (q *Queries) GetCell(ctx context.Context, id string) (Cell, error) {
	row := q.db.QueryRowContext(ctx, getCell, id)
	var i Cell
	err := row.Scan(
		&i.ID,
		&i.NotebookID,
		&i.CellType,
		&i.Content,
		&i.Position,
		&i.LastResult,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMaxCellPosition = `-- name: GetMaxCellPosition :one
SELECT COALESCE(MAX(position), -1) FROM cells WHERE notebook_id = ?
`

func (q *Queries) GetMaxCellPosition(ctx context.Context, notebookID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxCellPosition, notebookID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getNotebook = `-- name: GetNotebook :one
SELECT id, name, description, owner, created_at, updated_at, git_repo_id, git_path FROM notebooks WHERE id = ?
`

func (q *Queries) GetNotebook(ctx context.Context, id string) (Notebook, error) {
	row := q.db.QueryRowContext(ctx, getNotebook, id)
	var i Notebook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GitRepoID,
		&i.GitPath,
	)
	return i, err
}

const listCells = `-- name: ListCells :many
SELECT id, notebook_id, cell_type, content, position, last_result, created_at, updated_at FROM cells WHERE notebook_id = ? ORDER BY position ASC
`

func (q *Queries) ListCells(ctx context.Context, notebookID string) ([]Cell, error) {
	rows, err := q.db.QueryContext(ctx, listCells, notebookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cell
	for rows.Next() {
		var i Cell
		if err := rows.Scan(
			&i.ID,
			&i.NotebookID,
			&i.CellType,
			&i.Content,
			&i.Position,
			&i.LastResult,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotebooks = `-- name: ListNotebooks :many
SELECT id, name, description, owner, created_at, updated_at, git_repo_id, git_path FROM notebooks
WHERE (?3 IS NULL OR owner = ?3)
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type ListNotebooksParams struct {
	Owner  interface{}
	Limit  int64
	Offset int64
}

func (q *Queries) ListNotebooks(ctx context.Context, arg ListNotebooksParams) ([]Notebook, error) {
	rows, err := q.db.QueryContext(ctx, listNotebooks, arg.Owner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notebook
	for rows.Next() {
		var i Notebook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Owner,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GitRepoID,
			&i.GitPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCell = `-- name: UpdateCell :one
UPDATE cells
SET content = ?, position = ?, updated_at = datetime('now')
WHERE id = ?
RETURNING id, notebook_id, cell_type, content, position, last_result, created_at, updated_at
`

type UpdateCellParams struct {
	Content  string
	Position int64
	ID       string
}

func (q *Queries) UpdateCell(ctx context.Context, arg UpdateCellParams) (Cell, error) {
	row := q.db.QueryRowContext(ctx, updateCell, arg.Content, arg.Position, arg.ID)
	var i Cell
	err := row.Scan(
		&i.ID,
		&i.NotebookID,
		&i.CellType,
		&i.Content,
		&i.Position,
		&i.LastResult,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCellPosition = `-- name: UpdateCellPosition :exec
UPDATE cells SET position = ?, updated_at = datetime('now') WHERE id = ?
`

type UpdateCellPositionParams struct {
	Position int64
	ID       string
}

func (q *Queries) UpdateCellPosition(ctx context.Context, arg UpdateCellPositionParams) error {
	_, err := q.db.ExecContext(ctx, updateCellPosition, arg.Position, arg.ID)
	return err
}

const updateCellResult = `-- name: UpdateCellResult :exec
UPDATE cells SET last_result = ?, updated_at = datetime('now') WHERE id = ?
`

type UpdateCellResultParams struct {
	LastResult sql.NullString
	ID         string
}

func (q *Queries) UpdateCellResult(ctx context.Context, arg UpdateCellResultParams) error {
	_, err := q.db.ExecContext(ctx, updateCellResult, arg.LastResult, arg.ID)
	return err
}

const updateNotebook = `-- name: UpdateNotebook :one
UPDATE notebooks
SET name = ?, description = ?, updated_at = datetime('now')
WHERE id = ?
RETURNING id, name, description, owner, created_at, updated_at, git_repo_id, git_path
`

type UpdateNotebookParams struct {
	Name        string
	Description sql.NullString
	ID          string
}

func (q *Queries) UpdateNotebook(ctx context.Context, arg UpdateNotebookParams) (Notebook, error) {
	row := q.db.QueryRowContext(ctx, updateNotebook, arg.Name, arg.Description, arg.ID)
	var i Notebook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GitRepoID,
		&i.GitPath,
	)
	return i, err
}
