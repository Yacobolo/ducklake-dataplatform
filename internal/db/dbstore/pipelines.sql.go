// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pipelines.sql

package dbstore

import (
	"context"
	"database/sql"
)

const cancelPendingPipelineRuns = `-- name: CancelPendingPipelineRuns :exec
UPDATE pipeline_runs SET status = 'CANCELLED' WHERE pipeline_id = ? AND status = 'PENDING'
`

func (q *Queries) CancelPendingPipelineRuns(ctx context.Context, pipelineID string) error {
	_, err := q.db.ExecContext(ctx, cancelPendingPipelineRuns, pipelineID)
	return err
}

const countActivePipelineRuns = `-- name: CountActivePipelineRuns :one
SELECT COUNT(*) FROM pipeline_runs WHERE pipeline_id = ? AND status IN ('PENDING', 'RUNNING')
`

func (q *Queries) CountActivePipelineRuns(ctx context.Context, pipelineID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivePipelineRuns, pipelineID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPipelineRuns = `-- name: CountPipelineRuns :one
SELECT COUNT(*) FROM pipeline_runs
WHERE (CAST(? AS TEXT) IS NULL OR pipeline_id = ?)
  AND (CAST(? AS TEXT) IS NULL OR status = ?)
`

type CountPipelineRunsParams struct {
	Column1    string
	PipelineID string
	Column3    string
	Status     string
}

func (q *Queries) CountPipelineRuns(ctx context.Context, arg CountPipelineRunsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPipelineRuns,
		arg.Column1,
		arg.PipelineID,
		arg.Column3,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPipelines = `-- name: CountPipelines :one
SELECT COUNT(*) FROM pipelines
`

func (q *Queries) CountPipelines(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPipelines)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPipeline = `-- name: CreatePipeline :one
INSERT INTO pipelines (id, name, description, schedule_cron, is_paused, concurrency_limit, created_by)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, description, schedule_cron, is_paused, concurrency_limit, created_by, created_at, updated_at
`

type CreatePipelineParams struct {
	ID               string
	Name             string
	Description      string
	ScheduleCron     sql.NullString
	IsPaused         int64
	ConcurrencyLimit int64
	CreatedBy        string
}

func (q *Queries) CreatePipeline(ctx context.Context, arg CreatePipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, createPipeline,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ScheduleCron,
		arg.IsPaused,
		arg.ConcurrencyLimit,
		arg.CreatedBy,
	)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ScheduleCron,
		&i.IsPaused,
		&i.ConcurrencyLimit,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPipelineJob = `-- name: CreatePipelineJob :one
INSERT INTO pipeline_jobs (id, pipeline_id, name, compute_endpoint_id, depends_on, notebook_id, timeout_seconds, retry_count, job_order)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, pipeline_id, name, compute_endpoint_id, depends_on, notebook_id, timeout_seconds, retry_count, job_order, created_at
`

type CreatePipelineJobParams struct {
	ID                string
	PipelineID        string
	Name              string
	ComputeEndpointID sql.NullString
	DependsOn         string
	NotebookID        string
	TimeoutSeconds    sql.NullInt64
	RetryCount        int64
	JobOrder          int64
}

func (q *Queries) CreatePipelineJob(ctx context.Context, arg CreatePipelineJobParams) (PipelineJob, error) {
	row := q.db.QueryRowContext(ctx, createPipelineJob,
		arg.ID,
		arg.PipelineID,
		arg.Name,
		arg.ComputeEndpointID,
		arg.DependsOn,
		arg.NotebookID,
		arg.TimeoutSeconds,
		arg.RetryCount,
		arg.JobOrder,
	)
	var i PipelineJob
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Name,
		&i.ComputeEndpointID,
		&i.DependsOn,
		&i.NotebookID,
		&i.TimeoutSeconds,
		&i.RetryCount,
		&i.JobOrder,
		&i.CreatedAt,
	)
	return i, err
}

const createPipelineJobRun = `-- name: CreatePipelineJobRun :one
INSERT INTO pipeline_job_runs (id, run_id, job_id, job_name, status, retry_attempt)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, run_id, job_id, job_name, status, started_at, finished_at, error_message, retry_attempt, created_at
`

type CreatePipelineJobRunParams struct {
	ID           string
	RunID        string
	JobID        string
	JobName      string
	Status       string
	RetryAttempt int64
}

func (q *Queries) CreatePipelineJobRun(ctx context.Context, arg CreatePipelineJobRunParams) (PipelineJobRun, error) {
	row := q.db.QueryRowContext(ctx, createPipelineJobRun,
		arg.ID,
		arg.RunID,
		arg.JobID,
		arg.JobName,
		arg.Status,
		arg.RetryAttempt,
	)
	var i PipelineJobRun
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.JobID,
		&i.JobName,
		&i.Status,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ErrorMessage,
		&i.RetryAttempt,
		&i.CreatedAt,
	)
	return i, err
}

const createPipelineRun = `-- name: CreatePipelineRun :one
INSERT INTO pipeline_runs (id, pipeline_id, status, trigger_type, triggered_by, parameters, git_commit_hash)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, pipeline_id, status, trigger_type, triggered_by, parameters, git_commit_hash, started_at, finished_at, error_message, created_at
`

type CreatePipelineRunParams struct {
	ID            string
	PipelineID    string
	Status        string
	TriggerType   string
	TriggeredBy   string
	Parameters    string
	GitCommitHash sql.NullString
}

func (q *Queries) CreatePipelineRun(ctx context.Context, arg CreatePipelineRunParams) (PipelineRun, error) {
	row := q.db.QueryRowContext(ctx, createPipelineRun,
		arg.ID,
		arg.PipelineID,
		arg.Status,
		arg.TriggerType,
		arg.TriggeredBy,
		arg.Parameters,
		arg.GitCommitHash,
	)
	var i PipelineRun
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Status,
		&i.TriggerType,
		&i.TriggeredBy,
		&i.Parameters,
		&i.GitCommitHash,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const deletePipeline = `-- name: DeletePipeline :exec
DELETE FROM pipelines WHERE id = ?
`

func (q *Queries) DeletePipeline(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePipeline, id)
	return err
}

const deletePipelineJob = `-- name: DeletePipelineJob :exec
DELETE FROM pipeline_jobs WHERE id = ?
`

func (q *Queries) DeletePipelineJob(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePipelineJob, id)
	return err
}

const deletePipelineJobsByPipeline = `-- name: DeletePipelineJobsByPipeline :exec
DELETE FROM pipeline_jobs WHERE pipeline_id = ?
`

func (q *Queries) DeletePipelineJobsByPipeline(ctx context.Context, pipelineID string) error {
	_, err := q.db.ExecContext(ctx, deletePipelineJobsByPipeline, pipelineID)
	return err
}

const getPipelineByID = `-- name: GetPipelineByID :one
SELECT id, name, description, schedule_cron, is_paused, concurrency_limit, created_by, created_at, updated_at FROM pipelines WHERE id = ?
`

func (q *Queries) GetPipelineByID(ctx context.Context, id string) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, getPipelineByID, id)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ScheduleCron,
		&i.IsPaused,
		&i.ConcurrencyLimit,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPipelineByName = `-- name: GetPipelineByName :one
SELECT id, name, description, schedule_cron, is_paused, concurrency_limit, created_by, created_at, updated_at FROM pipelines WHERE name = ?
`

func (q *Queries) GetPipelineByName(ctx context.Context, name string) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, getPipelineByName, name)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ScheduleCron,
		&i.IsPaused,
		&i.ConcurrencyLimit,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPipelineJobByID = `-- name: GetPipelineJobByID :one
SELECT id, pipeline_id, name, compute_endpoint_id, depends_on, notebook_id, timeout_seconds, retry_count, job_order, created_at FROM pipeline_jobs WHERE id = ?
`

func (q *Queries) GetPipelineJobByID(ctx context.Context, id string) (PipelineJob, error) {
	row := q.db.QueryRowContext(ctx, getPipelineJobByID, id)
	var i PipelineJob
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Name,
		&i.ComputeEndpointID,
		&i.DependsOn,
		&i.NotebookID,
		&i.TimeoutSeconds,
		&i.RetryCount,
		&i.JobOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getPipelineJobRunByID = `-- name: GetPipelineJobRunByID :one
SELECT id, run_id, job_id, job_name, status, started_at, finished_at, error_message, retry_attempt, created_at FROM pipeline_job_runs WHERE id = ?
`

func (q *Queries) GetPipelineJobRunByID(ctx context.Context, id string) (PipelineJobRun, error) {
	row := q.db.QueryRowContext(ctx, getPipelineJobRunByID, id)
	var i PipelineJobRun
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.JobID,
		&i.JobName,
		&i.Status,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ErrorMessage,
		&i.RetryAttempt,
		&i.CreatedAt,
	)
	return i, err
}

const getPipelineRunByID = `-- name: GetPipelineRunByID :one
SELECT id, pipeline_id, status, trigger_type, triggered_by, parameters, git_commit_hash, started_at, finished_at, error_message, created_at FROM pipeline_runs WHERE id = ?
`

func (q *Queries) GetPipelineRunByID(ctx context.Context, id string) (PipelineRun, error) {
	row := q.db.QueryRowContext(ctx, getPipelineRunByID, id)
	var i PipelineRun
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Status,
		&i.TriggerType,
		&i.TriggeredBy,
		&i.Parameters,
		&i.GitCommitHash,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const listPipelineJobRunsByRun = `-- name: ListPipelineJobRunsByRun :many
SELECT id, run_id, job_id, job_name, status, started_at, finished_at, error_message, retry_attempt, created_at FROM pipeline_job_runs WHERE run_id = ? ORDER BY created_at
`

func (q *Queries) ListPipelineJobRunsByRun(ctx context.Context, runID string) ([]PipelineJobRun, error) {
	rows, err := q.db.QueryContext(ctx, listPipelineJobRunsByRun, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PipelineJobRun
	for rows.Next() {
		var i PipelineJobRun
		if err := rows.Scan(
			&i.ID,
			&i.RunID,
			&i.JobID,
			&i.JobName,
			&i.Status,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ErrorMessage,
			&i.RetryAttempt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPipelineJobsByPipeline = `-- name: ListPipelineJobsByPipeline :many
SELECT id, pipeline_id, name, compute_endpoint_id, depends_on, notebook_id, timeout_seconds, retry_count, job_order, created_at FROM pipeline_jobs WHERE pipeline_id = ? ORDER BY job_order, name
`

func (q *Queries) ListPipelineJobsByPipeline(ctx context.Context, pipelineID string) ([]PipelineJob, error) {
	rows, err := q.db.QueryContext(ctx, listPipelineJobsByPipeline, pipelineID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PipelineJob
	for rows.Next() {
		var i PipelineJob
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Name,
			&i.ComputeEndpointID,
			&i.DependsOn,
			&i.NotebookID,
			&i.TimeoutSeconds,
			&i.RetryCount,
			&i.JobOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPipelineRuns = `-- name: ListPipelineRuns :many
SELECT id, pipeline_id, status, trigger_type, triggered_by, parameters, git_commit_hash, started_at, finished_at, error_message, created_at FROM pipeline_runs
WHERE (CAST(? AS TEXT) IS NULL OR pipeline_id = ?)
  AND (CAST(? AS TEXT) IS NULL OR status = ?)
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListPipelineRunsParams struct {
	Column1    string
	PipelineID string
	Column3    string
	Status     string
	Limit      int64
	Offset     int64
}

func (q *Queries) ListPipelineRuns(ctx context.Context, arg ListPipelineRunsParams) ([]PipelineRun, error) {
	rows, err := q.db.QueryContext(ctx, listPipelineRuns,
		arg.Column1,
		arg.PipelineID,
		arg.Column3,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PipelineRun
	for rows.Next() {
		var i PipelineRun
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Status,
			&i.TriggerType,
			&i.TriggeredBy,
			&i.Parameters,
			&i.GitCommitHash,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPipelines = `-- name: ListPipelines :many
SELECT id, name, description, schedule_cron, is_paused, concurrency_limit, created_by, created_at, updated_at FROM pipelines ORDER BY name LIMIT ? OFFSET ?
`

type ListPipelinesParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListPipelines(ctx context.Context, arg ListPipelinesParams) ([]Pipeline, error) {
	rows, err := q.db.QueryContext(ctx, listPipelines, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pipeline
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ScheduleCron,
			&i.IsPaused,
			&i.ConcurrencyLimit,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledPipelines = `-- name: ListScheduledPipelines :many
SELECT id, name, description, schedule_cron, is_paused, concurrency_limit, created_by, created_at, updated_at FROM pipelines WHERE schedule_cron IS NOT NULL AND is_paused = 0
`

func (q *Queries) ListScheduledPipelines(ctx context.Context) ([]Pipeline, error) {
	rows, err := q.db.QueryContext(ctx, listScheduledPipelines)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pipeline
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ScheduleCron,
			&i.IsPaused,
			&i.ConcurrencyLimit,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePipeline = `-- name: UpdatePipeline :exec
UPDATE pipelines
SET description = COALESCE(?, description),
    schedule_cron = COALESCE(?, schedule_cron),
    is_paused = COALESCE(?, is_paused),
    concurrency_limit = COALESCE(?, concurrency_limit),
    updated_at = datetime('now')
WHERE id = ?
`

type UpdatePipelineParams struct {
	Description      string
	ScheduleCron     sql.NullString
	IsPaused         int64
	ConcurrencyLimit int64
	ID               string
}

func (q *Queries) UpdatePipeline(ctx context.Context, arg UpdatePipelineParams) error {
	_, err := q.db.ExecContext(ctx, updatePipeline,
		arg.Description,
		arg.ScheduleCron,
		arg.IsPaused,
		arg.ConcurrencyLimit,
		arg.ID,
	)
	return err
}

const updatePipelineJobRunFinished = `-- name: UpdatePipelineJobRunFinished :exec
UPDATE pipeline_job_runs SET status = ?, finished_at = datetime('now'), error_message = ? WHERE id = ?
`

type UpdatePipelineJobRunFinishedParams struct {
	Status       string
	ErrorMessage sql.NullString
	ID           string
}

func (q *Queries) UpdatePipelineJobRunFinished(ctx context.Context, arg UpdatePipelineJobRunFinishedParams) error {
	_, err := q.db.ExecContext(ctx, updatePipelineJobRunFinished, arg.Status, arg.ErrorMessage, arg.ID)
	return err
}

const updatePipelineJobRunStarted = `-- name: UpdatePipelineJobRunStarted :exec
UPDATE pipeline_job_runs SET status = 'RUNNING', started_at = datetime('now') WHERE id = ?
`

func (q *Queries) UpdatePipelineJobRunStarted(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updatePipelineJobRunStarted, id)
	return err
}

const updatePipelineJobRunStatus = `-- name: UpdatePipelineJobRunStatus :exec
UPDATE pipeline_job_runs SET status = ?, error_message = ? WHERE id = ?
`

type UpdatePipelineJobRunStatusParams struct {
	Status       string
	ErrorMessage sql.NullString
	ID           string
}

func (q *Queries) UpdatePipelineJobRunStatus(ctx context.Context, arg UpdatePipelineJobRunStatusParams) error {
	_, err := q.db.ExecContext(ctx, updatePipelineJobRunStatus, arg.Status, arg.ErrorMessage, arg.ID)
	return err
}

const updatePipelineRunFinished = `-- name: UpdatePipelineRunFinished :exec
UPDATE pipeline_runs SET status = ?, finished_at = datetime('now'), error_message = ? WHERE id = ?
`

type UpdatePipelineRunFinishedParams struct {
	Status       string
	ErrorMessage sql.NullString
	ID           string
}

func (q *Queries) UpdatePipelineRunFinished(ctx context.Context, arg UpdatePipelineRunFinishedParams) error {
	_, err := q.db.ExecContext(ctx, updatePipelineRunFinished, arg.Status, arg.ErrorMessage, arg.ID)
	return err
}

const updatePipelineRunStarted = `-- name: UpdatePipelineRunStarted :exec
UPDATE pipeline_runs SET status = 'RUNNING', started_at = datetime('now') WHERE id = ?
`

func (q *Queries) UpdatePipelineRunStarted(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updatePipelineRunStarted, id)
	return err
}

const updatePipelineRunStatus = `-- name: UpdatePipelineRunStatus :exec
UPDATE pipeline_runs SET status = ?, error_message = ? WHERE id = ?
`

type UpdatePipelineRunStatusParams struct {
	Status       string
	ErrorMessage sql.NullString
	ID           string
}

func (q *Queries) UpdatePipelineRunStatus(ctx context.Context, arg UpdatePipelineRunStatusParams) error {
	_, err := q.db.ExecContext(ctx, updatePipelineRunStatus, arg.Status, arg.ErrorMessage, arg.ID)
	return err
}
