// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: catalogs.sql

package dbstore

import (
	"context"
	"database/sql"
)

const clearDefaultCatalog = `-- name: ClearDefaultCatalog :exec
UPDATE catalogs SET is_default = 0, updated_at = datetime('now') WHERE is_default = 1
`

func (q *Queries) ClearDefaultCatalog(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearDefaultCatalog)
	return err
}

const countCatalogs = `-- name: CountCatalogs :one
SELECT COUNT(*) FROM catalogs
`

func (q *Queries) CountCatalogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCatalogs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCatalog = `-- name: CreateCatalog :one
INSERT INTO catalogs (id, name, metastore_type, dsn, data_path, status, status_message, is_default, comment)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, metastore_type, dsn, data_path, status, status_message, is_default, comment, created_at, updated_at
`

type CreateCatalogParams struct {
	ID            string
	Name          string
	MetastoreType string
	Dsn           string
	DataPath      string
	Status        string
	StatusMessage sql.NullString
	IsDefault     int64
	Comment       sql.NullString
}

func (q *Queries) CreateCatalog(ctx context.Context, arg CreateCatalogParams) (Catalog, error) {
	row := q.db.QueryRowContext(ctx, createCatalog,
		arg.ID,
		arg.Name,
		arg.MetastoreType,
		arg.Dsn,
		arg.DataPath,
		arg.Status,
		arg.StatusMessage,
		arg.IsDefault,
		arg.Comment,
	)
	var i Catalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MetastoreType,
		&i.Dsn,
		&i.DataPath,
		&i.Status,
		&i.StatusMessage,
		&i.IsDefault,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCatalog = `-- name: DeleteCatalog :exec
DELETE FROM catalogs WHERE id = ?
`

func (q *Queries) DeleteCatalog(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteCatalog, id)
	return err
}

const getCatalogByID = `-- name: GetCatalogByID :one
SELECT id, name, metastore_type, dsn, data_path, status, status_message, is_default, comment, created_at, updated_at FROM catalogs WHERE id = ?
`

func (q *Queries) GetCatalogByID(ctx context.Context, id string) (Catalog, error) {
	row := q.db.QueryRowContext(ctx, getCatalogByID, id)
	var i Catalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MetastoreType,
		&i.Dsn,
		&i.DataPath,
		&i.Status,
		&i.StatusMessage,
		&i.IsDefault,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCatalogByName = `-- name: GetCatalogByName :one
SELECT id, name, metastore_type, dsn, data_path, status, status_message, is_default, comment, created_at, updated_at FROM catalogs WHERE name = ?
`

func (q *Queries) GetCatalogByName(ctx context.Context, name string) (Catalog, error) {
	row := q.db.QueryRowContext(ctx, getCatalogByName, name)
	var i Catalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MetastoreType,
		&i.Dsn,
		&i.DataPath,
		&i.Status,
		&i.StatusMessage,
		&i.IsDefault,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDefaultCatalog = `-- name: GetDefaultCatalog :one
SELECT id, name, metastore_type, dsn, data_path, status, status_message, is_default, comment, created_at, updated_at FROM catalogs WHERE is_default = 1
`

func (q *Queries) GetDefaultCatalog(ctx context.Context) (Catalog, error) {
	row := q.db.QueryRowContext(ctx, getDefaultCatalog)
	var i Catalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MetastoreType,
		&i.Dsn,
		&i.DataPath,
		&i.Status,
		&i.StatusMessage,
		&i.IsDefault,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCatalogs = `-- name: ListCatalogs :many
SELECT id, name, metastore_type, dsn, data_path, status, status_message, is_default, comment, created_at, updated_at FROM catalogs ORDER BY name LIMIT ? OFFSET ?
`

type ListCatalogsParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListCatalogs(ctx context.Context, arg ListCatalogsParams) ([]Catalog, error) {
	rows, err := q.db.QueryContext(ctx, listCatalogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Catalog
	for rows.Next() {
		var i Catalog
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MetastoreType,
			&i.Dsn,
			&i.DataPath,
			&i.Status,
			&i.StatusMessage,
			&i.IsDefault,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultCatalog = `-- name: SetDefaultCatalog :exec
UPDATE catalogs SET is_default = 1, updated_at = datetime('now') WHERE id = ?
`

func (q *Queries) SetDefaultCatalog(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, setDefaultCatalog, id)
	return err
}

const updateCatalog = `-- name: UpdateCatalog :one
UPDATE catalogs
SET comment = COALESCE(?, comment),
    data_path = COALESCE(?, data_path),
    dsn = COALESCE(?, dsn),
    updated_at = datetime('now')
WHERE id = ?
RETURNING id, name, metastore_type, dsn, data_path, status, status_message, is_default, comment, created_at, updated_at
`

type UpdateCatalogParams struct {
	Comment  sql.NullString
	DataPath string
	Dsn      string
	ID       string
}

func (q *Queries) UpdateCatalog(ctx context.Context, arg UpdateCatalogParams) (Catalog, error) {
	row := q.db.QueryRowContext(ctx, updateCatalog,
		arg.Comment,
		arg.DataPath,
		arg.Dsn,
		arg.ID,
	)
	var i Catalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MetastoreType,
		&i.Dsn,
		&i.DataPath,
		&i.Status,
		&i.StatusMessage,
		&i.IsDefault,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCatalogStatus = `-- name: UpdateCatalogStatus :exec
UPDATE catalogs
SET status = ?, status_message = ?, updated_at = datetime('now')
WHERE id = ?
`

type UpdateCatalogStatusParams struct {
	Status        string
	StatusMessage sql.NullString
	ID            string
}

func (q *Queries) UpdateCatalogStatus(ctx context.Context, arg UpdateCatalogStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateCatalogStatus, arg.Status, arg.StatusMessage, arg.ID)
	return err
}
