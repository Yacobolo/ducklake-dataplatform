// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: column_masks.sql

package dbstore

import (
	"context"
	"database/sql"
)

const bindColumnMask = `-- name: BindColumnMask :exec
INSERT OR IGNORE INTO column_mask_bindings (id, column_mask_id, principal_id, principal_type, see_original)
VALUES (?, ?, ?, ?, ?)
`

type BindColumnMaskParams struct {
	ID            string
	ColumnMaskID  string
	PrincipalID   string
	PrincipalType string
	SeeOriginal   int64
}

func (q *Queries) BindColumnMask(ctx context.Context, arg BindColumnMaskParams) error {
	_, err := q.db.ExecContext(ctx, bindColumnMask,
		arg.ID,
		arg.ColumnMaskID,
		arg.PrincipalID,
		arg.PrincipalType,
		arg.SeeOriginal,
	)
	return err
}

const countColumnMasksForTable = `-- name: CountColumnMasksForTable :one
SELECT COUNT(*) as cnt FROM column_masks WHERE table_id = ?
`

func (q *Queries) CountColumnMasksForTable(ctx context.Context, tableID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countColumnMasksForTable, tableID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const createColumnMask = `-- name: CreateColumnMask :one
INSERT INTO column_masks (id, table_id, column_name, mask_expression, description)
VALUES (?, ?, ?, ?, ?)
RETURNING id, table_id, column_name, mask_expression, description, created_at
`

type CreateColumnMaskParams struct {
	ID             string
	TableID        string
	ColumnName     string
	MaskExpression string
	Description    sql.NullString
}

func (q *Queries) CreateColumnMask(ctx context.Context, arg CreateColumnMaskParams) (ColumnMask, error) {
	row := q.db.QueryRowContext(ctx, createColumnMask,
		arg.ID,
		arg.TableID,
		arg.ColumnName,
		arg.MaskExpression,
		arg.Description,
	)
	var i ColumnMask
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.ColumnName,
		&i.MaskExpression,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const deleteColumnMask = `-- name: DeleteColumnMask :exec
DELETE FROM column_masks WHERE id = ?
`

func (q *Queries) DeleteColumnMask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteColumnMask, id)
	return err
}

const deleteColumnMasksByTable = `-- name: DeleteColumnMasksByTable :exec
DELETE FROM column_masks WHERE table_id = ?
`

func (q *Queries) DeleteColumnMasksByTable(ctx context.Context, tableID string) error {
	_, err := q.db.ExecContext(ctx, deleteColumnMasksByTable, tableID)
	return err
}

const getColumnMaskBindingsForMask = `-- name: GetColumnMaskBindingsForMask :many
SELECT id, column_mask_id, principal_id, principal_type, see_original FROM column_mask_bindings WHERE column_mask_id = ?
`

func (q *Queries) GetColumnMaskBindingsForMask(ctx context.Context, columnMaskID string) ([]ColumnMaskBinding, error) {
	rows, err := q.db.QueryContext(ctx, getColumnMaskBindingsForMask, columnMaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ColumnMaskBinding
	for rows.Next() {
		var i ColumnMaskBinding
		if err := rows.Scan(
			&i.ID,
			&i.ColumnMaskID,
			&i.PrincipalID,
			&i.PrincipalType,
			&i.SeeOriginal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnMaskBindingsForPrincipal = `-- name: GetColumnMaskBindingsForPrincipal :many
SELECT cm.table_id, cm.column_name, cm.mask_expression, cmb.see_original
FROM column_masks cm
JOIN column_mask_bindings cmb ON cm.id = cmb.column_mask_id
WHERE cmb.principal_id = ? AND cmb.principal_type = ?
`

type GetColumnMaskBindingsForPrincipalParams struct {
	PrincipalID   string
	PrincipalType string
}

type GetColumnMaskBindingsForPrincipalRow struct {
	TableID        string
	ColumnName     string
	MaskExpression string
	SeeOriginal    int64
}

func (q *Queries) GetColumnMaskBindingsForPrincipal(ctx context.Context, arg GetColumnMaskBindingsForPrincipalParams) ([]GetColumnMaskBindingsForPrincipalRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumnMaskBindingsForPrincipal, arg.PrincipalID, arg.PrincipalType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetColumnMaskBindingsForPrincipalRow
	for rows.Next() {
		var i GetColumnMaskBindingsForPrincipalRow
		if err := rows.Scan(
			&i.TableID,
			&i.ColumnName,
			&i.MaskExpression,
			&i.SeeOriginal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnMaskForTableAndPrincipal = `-- name: GetColumnMaskForTableAndPrincipal :many
SELECT cm.column_name, cm.mask_expression, cmb.see_original
FROM column_masks cm
JOIN column_mask_bindings cmb ON cm.id = cmb.column_mask_id
WHERE cm.table_id = ? AND cmb.principal_id = ? AND cmb.principal_type = ?
`

type GetColumnMaskForTableAndPrincipalParams struct {
	TableID       string
	PrincipalID   string
	PrincipalType string
}

type GetColumnMaskForTableAndPrincipalRow struct {
	ColumnName     string
	MaskExpression string
	SeeOriginal    int64
}

func (q *Queries) GetColumnMaskForTableAndPrincipal(ctx context.Context, arg GetColumnMaskForTableAndPrincipalParams) ([]GetColumnMaskForTableAndPrincipalRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumnMaskForTableAndPrincipal, arg.TableID, arg.PrincipalID, arg.PrincipalType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetColumnMaskForTableAndPrincipalRow
	for rows.Next() {
		var i GetColumnMaskForTableAndPrincipalRow
		if err := rows.Scan(&i.ColumnName, &i.MaskExpression, &i.SeeOriginal); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnMasksForTable = `-- name: GetColumnMasksForTable :many
SELECT id, table_id, column_name, mask_expression, description, created_at FROM column_masks WHERE table_id = ?
`

func (q *Queries) GetColumnMasksForTable(ctx context.Context, tableID string) ([]ColumnMask, error) {
	rows, err := q.db.QueryContext(ctx, getColumnMasksForTable, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ColumnMask
	for rows.Next() {
		var i ColumnMask
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.ColumnName,
			&i.MaskExpression,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listColumnMasksForTablePaginated = `-- name: ListColumnMasksForTablePaginated :many
SELECT id, table_id, column_name, mask_expression, description, created_at FROM column_masks WHERE table_id = ? ORDER BY id LIMIT ? OFFSET ?
`

type ListColumnMasksForTablePaginatedParams struct {
	TableID string
	Limit   int64
	Offset  int64
}

func (q *Queries) ListColumnMasksForTablePaginated(ctx context.Context, arg ListColumnMasksForTablePaginatedParams) ([]ColumnMask, error) {
	rows, err := q.db.QueryContext(ctx, listColumnMasksForTablePaginated, arg.TableID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ColumnMask
	for rows.Next() {
		var i ColumnMask
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.ColumnName,
			&i.MaskExpression,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unbindColumnMask = `-- name: UnbindColumnMask :exec
DELETE FROM column_mask_bindings
WHERE column_mask_id = ? AND principal_id = ? AND principal_type = ?
`

type UnbindColumnMaskParams struct {
	ColumnMaskID  string
	PrincipalID   string
	PrincipalType string
}

func (q *Queries) UnbindColumnMask(ctx context.Context, arg UnbindColumnMaskParams) error {
	_, err := q.db.ExecContext(ctx, unbindColumnMask, arg.ColumnMaskID, arg.PrincipalID, arg.PrincipalType)
	return err
}
