package declarative

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

// ExportDirectory writes the given state as YAML files in the hierarchical
// directory structure under dir. If overwrite is false and dir is non-empty,
// it returns an error.
func ExportDirectory(dir string, state *DesiredState, overwrite bool) error {
	if !overwrite {
		if err := ensureEmptyOrMissing(dir); err != nil {
			return err
		}
	}

	// Security resources.
	if err := exportSecurity(dir, state); err != nil {
		return err
	}

	// Governance resources.
	if err := exportGovernance(dir, state); err != nil {
		return err
	}

	// Storage resources.
	if err := exportStorage(dir, state); err != nil {
		return err
	}

	// Compute resources.
	if err := exportCompute(dir, state); err != nil {
		return err
	}

	// Catalog hierarchy (catalogs, schemas, tables, views, volumes, row filters, column masks).
	if err := exportCatalogs(dir, state); err != nil {
		return err
	}

	// Notebooks.
	if err := exportNotebooks(dir, state); err != nil {
		return err
	}

	// Pipelines.
	if err := exportPipelines(dir, state); err != nil {
		return err
	}

	return nil
}

// ensureEmptyOrMissing returns an error if dir exists and contains entries.
func ensureEmptyOrMissing(dir string) error {
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return fmt.Errorf("check directory %s: %w", dir, err)
	}
	if len(entries) > 0 {
		return fmt.Errorf("directory %s is not empty; use overwrite to replace existing files", dir)
	}
	return nil
}

// writeYAMLFile marshals v to YAML and writes it to path with a header comment.
// Parent directories are created as needed.
func writeYAMLFile(path string, v interface{}) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return fmt.Errorf("create directory for %s: %w", path, err)
	}
	data, err := yaml.Marshal(v)
	if err != nil {
		return fmt.Errorf("marshal %s: %w", path, err)
	}
	header := []byte("# Generated by duck export. Edit as needed.\n")
	content := append(header, data...)
	if err := os.WriteFile(path, content, 0o644); err != nil {
		return fmt.Errorf("write %s: %w", path, err)
	}
	return nil
}

// === Security ===

func exportSecurity(dir string, state *DesiredState) error {
	if len(state.Principals) > 0 {
		doc := PrincipalListDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNamePrincipalList,
			Principals: state.Principals,
		}
		if err := writeYAMLFile(filepath.Join(dir, "security", "principals.yaml"), doc); err != nil {
			return err
		}
	}

	if len(state.Groups) > 0 {
		doc := GroupListDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameGroupList,
			Groups:     state.Groups,
		}
		if err := writeYAMLFile(filepath.Join(dir, "security", "groups.yaml"), doc); err != nil {
			return err
		}
	}

	if len(state.Grants) > 0 {
		doc := GrantListDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameGrantList,
			Grants:     state.Grants,
		}
		if err := writeYAMLFile(filepath.Join(dir, "security", "grants.yaml"), doc); err != nil {
			return err
		}
	}

	if len(state.APIKeys) > 0 {
		doc := APIKeyListDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameAPIKeyList,
			APIKeys:    state.APIKeys,
		}
		if err := writeYAMLFile(filepath.Join(dir, "security", "api-keys.yaml"), doc); err != nil {
			return err
		}
	}

	return nil
}

// === Governance ===

func exportGovernance(dir string, state *DesiredState) error {
	if len(state.Tags) == 0 && len(state.TagAssignments) == 0 {
		return nil
	}

	doc := TagConfigDoc{
		APIVersion:  SupportedAPIVersion,
		Kind:        KindNameTagConfig,
		Tags:        state.Tags,
		Assignments: state.TagAssignments,
	}
	return writeYAMLFile(filepath.Join(dir, "governance", "tags.yaml"), doc)
}

// === Storage ===

func exportStorage(dir string, state *DesiredState) error {
	if len(state.StorageCredentials) > 0 {
		creds := sanitizeCredentials(state.StorageCredentials)
		doc := StorageCredentialListDoc{
			APIVersion:  SupportedAPIVersion,
			Kind:        KindNameStorageCredentialList,
			Credentials: creds,
		}
		if err := writeYAMLFile(filepath.Join(dir, "storage", "credentials.yaml"), doc); err != nil {
			return err
		}
	}

	if len(state.ExternalLocations) > 0 {
		doc := ExternalLocationListDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameExternalLocationList,
			Locations:  state.ExternalLocations,
		}
		if err := writeYAMLFile(filepath.Join(dir, "storage", "locations.yaml"), doc); err != nil {
			return err
		}
	}

	return nil
}

// sanitizeCredentials replaces empty secret _from_env fields with "REPLACE_ME"
// placeholders so the exported YAML hints that configuration is needed.
func sanitizeCredentials(creds []StorageCredentialSpec) []StorageCredentialSpec {
	out := make([]StorageCredentialSpec, len(creds))
	copy(out, creds)
	for i := range out {
		if out[i].S3 != nil {
			s3 := *out[i].S3
			if s3.KeyIDFromEnv == "" {
				s3.KeyIDFromEnv = "REPLACE_ME"
			}
			if s3.SecretFromEnv == "" {
				s3.SecretFromEnv = "REPLACE_ME"
			}
			out[i].S3 = &s3
		}
		if out[i].Azure != nil {
			az := *out[i].Azure
			if az.AccountNameFromEnv == "" {
				az.AccountNameFromEnv = "REPLACE_ME"
			}
			if az.AccountKeyFromEnv == "" {
				az.AccountKeyFromEnv = "REPLACE_ME"
			}
			out[i].Azure = &az
		}
		// GCS uses key_file_path, no secret env var to sanitize.
	}
	return out
}

// === Compute ===

func exportCompute(dir string, state *DesiredState) error {
	if len(state.ComputeEndpoints) > 0 {
		doc := ComputeEndpointListDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameComputeEndpointList,
			Endpoints:  state.ComputeEndpoints,
		}
		if err := writeYAMLFile(filepath.Join(dir, "compute", "endpoints.yaml"), doc); err != nil {
			return err
		}
	}

	if len(state.ComputeAssignments) > 0 {
		doc := ComputeAssignmentListDoc{
			APIVersion:  SupportedAPIVersion,
			Kind:        KindNameComputeAssignmentList,
			Assignments: state.ComputeAssignments,
		}
		if err := writeYAMLFile(filepath.Join(dir, "compute", "assignments.yaml"), doc); err != nil {
			return err
		}
	}

	return nil
}

// === Catalogs ===

func exportCatalogs(dir string, state *DesiredState) error {
	// Catalogs.
	for _, cat := range state.Catalogs {
		doc := CatalogDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameCatalog,
			Metadata: ObjectMeta{
				Name:               cat.CatalogName,
				DeletionProtection: cat.DeletionProtection,
			},
			Spec: cat.Spec,
		}
		path := filepath.Join(dir, "catalogs", cat.CatalogName, "catalog.yaml")
		if err := writeYAMLFile(path, doc); err != nil {
			return err
		}
	}

	// Schemas.
	for _, sch := range state.Schemas {
		doc := SchemaDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameSchema,
			Metadata: ObjectMeta{
				Name:               sch.SchemaName,
				DeletionProtection: sch.DeletionProtection,
			},
			Spec: sch.Spec,
		}
		path := filepath.Join(dir, "catalogs", sch.CatalogName, "schemas", sch.SchemaName, "schema.yaml")
		if err := writeYAMLFile(path, doc); err != nil {
			return err
		}
	}

	// Tables.
	for _, tbl := range state.Tables {
		doc := TableDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameTable,
			Metadata: ObjectMeta{
				Name:               tbl.TableName,
				DeletionProtection: tbl.DeletionProtection,
			},
			Spec: tbl.Spec,
		}
		path := filepath.Join(dir, "catalogs", tbl.CatalogName, "schemas", tbl.SchemaName, "tables", tbl.TableName, "table.yaml")
		if err := writeYAMLFile(path, doc); err != nil {
			return err
		}
	}

	// Row filters.
	for _, rf := range state.RowFilters {
		if len(rf.Filters) == 0 {
			continue
		}
		doc := RowFilterListDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameRowFilterList,
			Filters:    rf.Filters,
		}
		path := filepath.Join(dir, "catalogs", rf.CatalogName, "schemas", rf.SchemaName, "tables", rf.TableName, "row-filters.yaml")
		if err := writeYAMLFile(path, doc); err != nil {
			return err
		}
	}

	// Column masks.
	for _, cm := range state.ColumnMasks {
		if len(cm.Masks) == 0 {
			continue
		}
		doc := ColumnMaskListDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameColumnMaskList,
			Masks:      cm.Masks,
		}
		path := filepath.Join(dir, "catalogs", cm.CatalogName, "schemas", cm.SchemaName, "tables", cm.TableName, "column-masks.yaml")
		if err := writeYAMLFile(path, doc); err != nil {
			return err
		}
	}

	// Views.
	for _, v := range state.Views {
		doc := ViewDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameView,
			Metadata:   ObjectMeta{Name: v.ViewName},
			Spec:       v.Spec,
		}
		path := filepath.Join(dir, "catalogs", v.CatalogName, "schemas", v.SchemaName, "views", v.ViewName+".yaml")
		if err := writeYAMLFile(path, doc); err != nil {
			return err
		}
	}

	// Volumes.
	for _, vol := range state.Volumes {
		doc := VolumeDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameVolume,
			Metadata:   ObjectMeta{Name: vol.VolumeName},
			Spec:       vol.Spec,
		}
		path := filepath.Join(dir, "catalogs", vol.CatalogName, "schemas", vol.SchemaName, "volumes", vol.VolumeName+".yaml")
		if err := writeYAMLFile(path, doc); err != nil {
			return err
		}
	}

	return nil
}

// === Notebooks ===

func exportNotebooks(dir string, state *DesiredState) error {
	for _, nb := range state.Notebooks {
		doc := NotebookDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNameNotebook,
			Metadata:   ObjectMeta{Name: nb.Name},
			Spec:       nb.Spec,
		}
		path := filepath.Join(dir, "notebooks", nb.Name+".yaml")
		if err := writeYAMLFile(path, doc); err != nil {
			return err
		}
	}
	return nil
}

// === Pipelines ===

func exportPipelines(dir string, state *DesiredState) error {
	for _, pl := range state.Pipelines {
		doc := PipelineDoc{
			APIVersion: SupportedAPIVersion,
			Kind:       KindNamePipeline,
			Metadata:   ObjectMeta{Name: pl.Name},
			Spec:       pl.Spec,
		}
		path := filepath.Join(dir, "pipelines", pl.Name+".yaml")
		if err := writeYAMLFile(path, doc); err != nil {
			return err
		}
	}
	return nil
}
