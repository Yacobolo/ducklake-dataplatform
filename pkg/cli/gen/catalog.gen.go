// Code generated by cli-gen. DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strings"

	"github.com/spf13/cobra"
)

func newCatalogCmd(client *Client) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "catalog",
		Short: "Manage the data catalog",
	}

	catalogsCmd := &cobra.Command{
		Use:   "catalogs",
		Short: "Manage catalogs",
	}
	cmd.AddCommand(catalogsCmd)

	columnsCmd := &cobra.Command{
		Use:   "columns",
		Short: "Manage columns",
	}
	cmd.AddCommand(columnsCmd)

	schemasCmd := &cobra.Command{
		Use:   "schemas",
		Short: "Manage schemas",
	}
	cmd.AddCommand(schemasCmd)

	tablesCmd := &cobra.Command{
		Use:   "tables",
		Short: "Manage tables",
	}
	cmd.AddCommand(tablesCmd)

	viewsCmd := &cobra.Command{
		Use:   "views",
		Short: "Manage views",
	}
	cmd.AddCommand(viewsCmd)

	volumesCmd := &cobra.Command{
		Use:   "volumes",
		Short: "Manage volumes",
	}
	cmd.AddCommand(volumesCmd)

	// createSchema
	{
		c := &cobra.Command{
			Use:     "create <name>",
			Short:   "Create a new schema",
			Long:    "Creates a new schema in the catalog with the specified name and optional properties.",
			Example: "duck catalog schemas create analytics --comment \"Analytics data schema\"",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas"
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("location-name") {
						v, _ := cmd.Flags().GetString("location-name")
						m["location_name"] = v
					}
					if cmd.Flags().Changed("properties") {
						v, _ := cmd.Flags().GetStringSlice("properties")
						m["properties"] = v
					}
					m["name"] = args[0]
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().String("comment", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("location-name", "", "Optional external location name to use for schema storage path.")
		c.Flags().StringSlice("properties", nil, "properties (key=value pairs)")

		// Apply overrides
		if fn, ok := runOverrides["createSchema"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createSchema"]; ok {
			fn(c)
		}
		schemasCmd.AddCommand(c)
	}

	// createTable
	{
		c := &cobra.Command{
			Use:     "create <schema-name>",
			Short:   "Create a new table in a schema",
			Long:    "Creates a new table with the specified columns and properties within the given schema.",
			Example: "duck catalog tables create <schema-name> --columns id:BIGINT --columns email:VARCHAR --comment \"User accounts table\" --name users",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/tables"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("columns") {
						v, _ := cmd.Flags().GetStringSlice("columns")
						// Compound flag: parse "name:type" format
						var items []map[string]interface{}
						for _, item := range v {
							parts := strings.SplitN(item, ":", 2)
							if len(parts) != 2 {
								return fmt.Errorf("invalid format for --columns: expected name:type")
							}
							entry := map[string]interface{}{}
							entry["name"] = parts[0]
							entry["type"] = parts[1]
							items = append(items, entry)
						}
						m["columns"] = items
					}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("file-format") {
						v, _ := cmd.Flags().GetString("file-format")
						m["file_format"] = v
					}
					if cmd.Flags().Changed("location-name") {
						v, _ := cmd.Flags().GetString("location-name")
						m["location_name"] = v
					}
					if cmd.Flags().Changed("name") {
						v, _ := cmd.Flags().GetString("name")
						m["name"] = v
					}
					if cmd.Flags().Changed("source-path") {
						v, _ := cmd.Flags().GetString("source-path")
						m["source_path"] = v
					}
					if cmd.Flags().Changed("table-type") {
						v, _ := cmd.Flags().GetString("table-type")
						m["table_type"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().StringSlice("columns", nil, "Compound flag: columns (format: name:type)")
		c.Flags().String("comment", "", "")
		c.Flags().String("file-format", "parquet", "File format of the external data. Required for EXTERNAL tables.")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("location-name", "", "Name of the external location that owns the source path. Required for EXTERNAL tables.")
		c.Flags().String("name", "", "")
		_ = c.MarkFlagRequired("name")
		c.Flags().String("source-path", "", "S3/storage path to the data file(s). Required for EXTERNAL tables.")
		c.Flags().String("table-type", "MANAGED", "Type of table. MANAGED (default) or EXTERNAL.")

		// Apply overrides
		if fn, ok := runOverrides["createTable"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createTable"]; ok {
			fn(c)
		}
		tablesCmd.AddCommand(c)
	}

	// createView
	{
		c := &cobra.Command{
			Use:     "create <schema-name>",
			Short:   "Create a view in a schema",
			Long:    "Creates a new view with the specified SQL definition within the given schema.",
			Example: "duck catalog views create <schema-name> --comment \"Active users view\" --name active_users --view-definition \"SELECT * FROM main.users WHERE active = true\"",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/views"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("name") {
						v, _ := cmd.Flags().GetString("name")
						m["name"] = v
					}
					if cmd.Flags().Changed("view-definition") {
						v, _ := cmd.Flags().GetString("view-definition")
						m["view_definition"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().String("comment", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("name", "", "")
		_ = c.MarkFlagRequired("name")
		c.Flags().String("view-definition", "", "")
		_ = c.MarkFlagRequired("view-definition")

		// Apply overrides
		if fn, ok := runOverrides["createView"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createView"]; ok {
			fn(c)
		}
		viewsCmd.AddCommand(c)
	}

	// createVolume
	{
		c := &cobra.Command{
			Use:     "create <schema-name>",
			Short:   "Create a volume in a schema",
			Long:    "Creates a new volume. EXTERNAL volumes require a storage_location. MANAGED volumes auto-generate a storage location. Requires CREATE_VOLUME on catalog.\n",
			Example: "duck catalog volumes create <schema-name> --comment \"Raw data ingestion volume\" --name raw_data --volume-type MANAGED",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/volumes"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("name") {
						v, _ := cmd.Flags().GetString("name")
						m["name"] = v
					}
					if cmd.Flags().Changed("storage-location") {
						v, _ := cmd.Flags().GetString("storage-location")
						m["storage_location"] = v
					}
					if cmd.Flags().Changed("volume-type") {
						v, _ := cmd.Flags().GetString("volume-type")
						m["volume_type"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().String("comment", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("name", "", "")
		_ = c.MarkFlagRequired("name")
		c.Flags().String("storage-location", "", "Required for EXTERNAL volumes. Ignored for MANAGED.")
		c.Flags().String("volume-type", "", "")
		_ = c.MarkFlagRequired("volume-type")

		// Apply overrides
		if fn, ok := runOverrides["createVolume"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createVolume"]; ok {
			fn(c)
		}
		volumesCmd.AddCommand(c)
	}

	// deleteCatalogRegistration
	{
		c := &cobra.Command{
			Use:     "delete <catalog-name>",
			Short:   "Delete a catalog registration",
			Long:    "Removes a catalog registration. Does not delete the underlying data.",
			Example: "duck catalog catalogs delete <catalog-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/catalogs/{catalogName}"
				urlPath = strings.Replace(urlPath, "{catalogName}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteCatalogRegistration"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteCatalogRegistration"]; ok {
			fn(c)
		}
		catalogsCmd.AddCommand(c)
	}

	// deleteSchema
	{
		c := &cobra.Command{
			Use:     "delete <schema-name>",
			Short:   "Delete a schema",
			Long:    "Permanently removes a schema from the catalog. Use the force parameter to delete schemas that still contain tables.",
			Example: "duck catalog schemas delete <schema-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				if cmd.Flags().Changed("force") {
					v, _ := cmd.Flags().GetBool("force")
					query.Set("force", fmt.Sprintf("%t", v))
				}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().Bool("force", false, "Force deletion even if the schema contains tables.")
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteSchema"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteSchema"]; ok {
			fn(c)
		}
		schemasCmd.AddCommand(c)
	}

	// deleteTable
	{
		c := &cobra.Command{
			Use:     "delete <schema-name> <table-name>",
			Short:   "Delete a table",
			Long:    "Permanently removes a table and all its data from the schema.",
			Example: "duck catalog tables delete <schema-name> <table-name>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/tables/{tableName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{tableName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteTable"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteTable"]; ok {
			fn(c)
		}
		tablesCmd.AddCommand(c)
	}

	// deleteView
	{
		c := &cobra.Command{
			Use:     "delete <schema-name> <view-name>",
			Short:   "Delete a view",
			Long:    "Permanently removes a view from the schema.",
			Example: "duck catalog views delete <schema-name> <view-name>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/views/{viewName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{viewName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteView"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteView"]; ok {
			fn(c)
		}
		viewsCmd.AddCommand(c)
	}

	// deleteVolume
	{
		c := &cobra.Command{
			Use:     "delete <schema-name> <volume-name>",
			Short:   "Delete a volume",
			Long:    "Deletes a volume. Requires CREATE_VOLUME on catalog.",
			Example: "duck catalog volumes delete <schema-name> <volume-name>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/volumes/{volumeName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{volumeName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteVolume"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteVolume"]; ok {
			fn(c)
		}
		volumesCmd.AddCommand(c)
	}

	// getCatalog
	{
		c := &cobra.Command{
			Use:   "get",
			Short: "Get catalog info",
			Long:  "Returns information about a DuckLake catalog.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/info"
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")

		// Apply overrides
		if fn, ok := runOverrides["getCatalog"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getCatalog"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	// getCatalogRegistration
	{
		c := &cobra.Command{
			Use:     "get <catalog-name>",
			Short:   "Get a catalog registration by name",
			Long:    "Returns the registration details for a specific catalog.",
			Example: "duck catalog catalogs get <catalog-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}"
				urlPath = strings.Replace(urlPath, "{catalogName}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["getCatalogRegistration"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getCatalogRegistration"]; ok {
			fn(c)
		}
		catalogsCmd.AddCommand(c)
	}

	// getSchema
	{
		c := &cobra.Command{
			Use:     "get <schema-name>",
			Short:   "Get a schema by name",
			Long:    "Retrieves the details of a specific schema by its name.",
			Example: "duck catalog schemas get <schema-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")

		// Apply overrides
		if fn, ok := runOverrides["getSchema"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getSchema"]; ok {
			fn(c)
		}
		schemasCmd.AddCommand(c)
	}

	// getTable
	{
		c := &cobra.Command{
			Use:     "get <schema-name> <table-name>",
			Short:   "Get a table by name",
			Long:    "Retrieves the details of a specific table, including its column definitions.",
			Example: "duck catalog tables get <schema-name> <table-name>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/tables/{tableName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{tableName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")

		// Apply overrides
		if fn, ok := runOverrides["getTable"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getTable"]; ok {
			fn(c)
		}
		tablesCmd.AddCommand(c)
	}

	// getView
	{
		c := &cobra.Command{
			Use:     "get <schema-name> <view-name>",
			Short:   "Get a view by name",
			Long:    "Retrieves the details of a specific view, including its SQL definition.",
			Example: "duck catalog views get <schema-name> <view-name>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/views/{viewName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{viewName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")

		// Apply overrides
		if fn, ok := runOverrides["getView"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getView"]; ok {
			fn(c)
		}
		viewsCmd.AddCommand(c)
	}

	// getVolume
	{
		c := &cobra.Command{
			Use:     "get <schema-name> <volume-name>",
			Short:   "Get a volume by name",
			Long:    "Retrieves the details of a specific volume by its name within the schema.",
			Example: "duck catalog volumes get <schema-name> <volume-name>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/volumes/{volumeName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{volumeName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")

		// Apply overrides
		if fn, ok := runOverrides["getVolume"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getVolume"]; ok {
			fn(c)
		}
		volumesCmd.AddCommand(c)
	}

	// listCatalogs
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List all registered catalogs",
			Long:  "Returns a list of all registered catalogs.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs"
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listCatalogs"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listCatalogs"]; ok {
			fn(c)
		}
		catalogsCmd.AddCommand(c)
	}

	// listSchemas
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List schemas in the catalog",
			Long:  "Returns a paginated list of all schemas defined in the catalog.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas"
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"schema_id", "name", "catalog_name", "owner", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listSchemas"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listSchemas"]; ok {
			fn(c)
		}
		schemasCmd.AddCommand(c)
	}

	// listTableColumns
	{
		c := &cobra.Command{
			Use:     "list <schema-name> <table-name>",
			Short:   "List columns of a table",
			Long:    "Returns a paginated list of all columns defined in the specified table.",
			Example: "duck catalog columns list <schema-name> <table-name>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/tables/{tableName}/columns"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{tableName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"name", "type", "position", "nullable", "comment"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listTableColumns"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listTableColumns"]; ok {
			fn(c)
		}
		columnsCmd.AddCommand(c)
	}

	// listTables
	{
		c := &cobra.Command{
			Use:     "list <schema-name>",
			Short:   "List tables in a schema",
			Long:    "Returns a paginated list of all tables within the specified schema.",
			Example: "duck catalog tables list <schema-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/tables"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"table_id", "name", "schema_name", "table_type", "owner", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listTables"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listTables"]; ok {
			fn(c)
		}
		tablesCmd.AddCommand(c)
	}

	// listViews
	{
		c := &cobra.Command{
			Use:     "list <schema-name>",
			Short:   "List views in a schema",
			Long:    "Returns a paginated list of all views defined within the specified schema.",
			Example: "duck catalog views list <schema-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/views"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "name", "schema_name", "owner", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listViews"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listViews"]; ok {
			fn(c)
		}
		viewsCmd.AddCommand(c)
	}

	// listVolumes
	{
		c := &cobra.Command{
			Use:     "list <schema-name>",
			Short:   "List volumes in a schema",
			Long:    "Returns a paginated list of all volumes defined within the specified schema.",
			Example: "duck catalog volumes list <schema-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/volumes"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "name", "volume_type", "storage_location", "owner", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listVolumes"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listVolumes"]; ok {
			fn(c)
		}
		volumesCmd.AddCommand(c)
	}

	// profileTable
	{
		c := &cobra.Command{
			Use:     "profile <schema-name> <table-name>",
			Short:   "Profile a table to collect statistics",
			Long:    "Runs profiling queries and stores statistics (row count, column count, size).",
			Example: "duck catalog tables profile <schema-name> <table-name>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/tables/{tableName}/profile"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{tableName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")

		// Apply overrides
		if fn, ok := runOverrides["profileTable"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["profileTable"]; ok {
			fn(c)
		}
		tablesCmd.AddCommand(c)
	}

	// registerCatalog
	{
		c := &cobra.Command{
			Use:     "register",
			Short:   "Register a new catalog",
			Long:    "Registers a new DuckLake catalog with the platform.",
			Example: "duck catalog catalogs register --comment \"Analytics data catalog\" --data-path s3://my-bucket/analytics/ --dsn /data/analytics.db --metastore-type sqlite --name analytics",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs"
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("data-path") {
						v, _ := cmd.Flags().GetString("data-path")
						m["data_path"] = v
					}
					if cmd.Flags().Changed("dsn") {
						v, _ := cmd.Flags().GetString("dsn")
						m["dsn"] = v
					}
					if cmd.Flags().Changed("metastore-type") {
						v, _ := cmd.Flags().GetString("metastore-type")
						m["metastore_type"] = v
					}
					if cmd.Flags().Changed("name") {
						v, _ := cmd.Flags().GetString("name")
						m["name"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("comment", "", "")
		c.Flags().String("data-path", "", "")
		_ = c.MarkFlagRequired("data-path")
		c.Flags().String("dsn", "", "")
		_ = c.MarkFlagRequired("dsn")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("metastore-type", "", "")
		_ = c.MarkFlagRequired("metastore-type")
		c.Flags().String("name", "", "")
		_ = c.MarkFlagRequired("name")

		// Apply overrides
		if fn, ok := runOverrides["registerCatalog"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["registerCatalog"]; ok {
			fn(c)
		}
		catalogsCmd.AddCommand(c)
	}

	// setDefaultCatalog
	{
		c := &cobra.Command{
			Use:     "set-default <catalog-name>",
			Short:   "Set a catalog as the default",
			Long:    "Sets the specified catalog as the default catalog for the platform.",
			Example: "duck catalog catalogs set-default <catalog-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/set-default"
				urlPath = strings.Replace(urlPath, "{catalogName}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")

		// Apply overrides
		if fn, ok := runOverrides["setDefaultCatalog"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["setDefaultCatalog"]; ok {
			fn(c)
		}
		catalogsCmd.AddCommand(c)
	}

	// updateCatalogRegistration
	{
		c := &cobra.Command{
			Use:     "update <catalog-name>",
			Short:   "Update a catalog registration",
			Long:    "Updates the registration details for a catalog.",
			Example: "duck catalog catalogs update <catalog-name> --comment \"Updated analytics catalog\" --data-path s3://new-bucket/analytics/",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}"
				urlPath = strings.Replace(urlPath, "{catalogName}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("data-path") {
						v, _ := cmd.Flags().GetString("data-path")
						m["data_path"] = v
					}
					if cmd.Flags().Changed("dsn") {
						v, _ := cmd.Flags().GetString("dsn")
						m["dsn"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("comment", "", "")
		c.Flags().String("data-path", "", "")
		c.Flags().String("dsn", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")

		// Apply overrides
		if fn, ok := runOverrides["updateCatalogRegistration"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updateCatalogRegistration"]; ok {
			fn(c)
		}
		catalogsCmd.AddCommand(c)
	}

	// updateColumn
	{
		c := &cobra.Command{
			Use:     "update <schema-name> <table-name> <column-name>",
			Short:   "Update column metadata",
			Long:    "Updates the metadata of a specific column, such as its comment or nullable flag.",
			Example: "duck catalog columns update <schema-name> <table-name> <column-name> --comment \"Updated column description\"",
			Args:    cobra.ExactArgs(3),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{tableName}", args[1], 1)
				urlPath = strings.Replace(urlPath, "{columnName}", args[2], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("properties") {
						v, _ := cmd.Flags().GetStringSlice("properties")
						m["properties"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().String("comment", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().StringSlice("properties", nil, "properties (key=value pairs)")

		// Apply overrides
		if fn, ok := runOverrides["updateColumn"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updateColumn"]; ok {
			fn(c)
		}
		columnsCmd.AddCommand(c)
	}

	// updateSchema
	{
		c := &cobra.Command{
			Use:     "update <schema-name>",
			Short:   "Update schema metadata",
			Long:    "Updates the metadata of an existing schema, such as its comment or properties.",
			Example: "duck catalog schemas update <schema-name> --comment \"Updated schema description\" --properties team=data-eng",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("properties") {
						v, _ := cmd.Flags().GetStringSlice("properties")
						m["properties"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().String("comment", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().StringSlice("properties", nil, "properties (key=value pairs)")

		// Apply overrides
		if fn, ok := runOverrides["updateSchema"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updateSchema"]; ok {
			fn(c)
		}
		schemasCmd.AddCommand(c)
	}

	// updateTable
	{
		c := &cobra.Command{
			Use:     "update <schema-name> <table-name>",
			Short:   "Update table metadata",
			Long:    "Updates the metadata of an existing table, such as its comment or properties.",
			Example: "duck catalog tables update <schema-name> <table-name> --comment \"Updated table description\" --owner alice",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/tables/{tableName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{tableName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("owner") {
						v, _ := cmd.Flags().GetString("owner")
						m["owner"] = v
					}
					if cmd.Flags().Changed("properties") {
						v, _ := cmd.Flags().GetStringSlice("properties")
						m["properties"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().String("comment", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("owner", "", "")
		c.Flags().StringSlice("properties", nil, "properties (key=value pairs)")

		// Apply overrides
		if fn, ok := runOverrides["updateTable"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updateTable"]; ok {
			fn(c)
		}
		tablesCmd.AddCommand(c)
	}

	// updateView
	{
		c := &cobra.Command{
			Use:     "update <schema-name> <view-name>",
			Short:   "Update a view's metadata",
			Long:    "Updates the metadata of an existing view, such as its comment or SQL definition.",
			Example: "duck catalog views update <schema-name> <view-name> --comment \"Updated view description\" --view-definition \"SELECT * FROM main.users WHERE active = true AND verified = true\"",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/views/{viewName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{viewName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("properties") {
						v, _ := cmd.Flags().GetStringSlice("properties")
						m["properties"] = v
					}
					if cmd.Flags().Changed("view-definition") {
						v, _ := cmd.Flags().GetString("view-definition")
						m["view_definition"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().String("comment", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().StringSlice("properties", nil, "properties (key=value pairs)")
		c.Flags().String("view-definition", "", "")

		// Apply overrides
		if fn, ok := runOverrides["updateView"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updateView"]; ok {
			fn(c)
		}
		viewsCmd.AddCommand(c)
	}

	// updateVolume
	{
		c := &cobra.Command{
			Use:     "update <schema-name> <volume-name>",
			Short:   "Update a volume",
			Long:    "Updates volume fields. Requires CREATE_VOLUME on catalog.",
			Example: "duck catalog volumes update <schema-name> <volume-name> --comment \"Updated volume description\" --new-name raw_data_v2",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/catalogs/{catalogName}/schemas/{schemaName}/volumes/{volumeName}"
				urlPath = strings.Replace(urlPath, "{schemaName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{volumeName}", args[1], 1)
				if cmd.Flags().Changed("catalog-name") {
					v, _ := cmd.Flags().GetString("catalog-name")
					urlPath = strings.Replace(urlPath, "{catalogName}", v, 1)
				}
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("new-name") {
						v, _ := cmd.Flags().GetString("new-name")
						m["new_name"] = v
					}
					if cmd.Flags().Changed("owner") {
						v, _ := cmd.Flags().GetString("owner")
						m["owner"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("catalog-name", "", "Name of the catalog.")
		_ = c.MarkFlagRequired("catalog-name")
		c.Flags().String("comment", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("new-name", "", "")
		c.Flags().String("owner", "", "")

		// Apply overrides
		if fn, ok := runOverrides["updateVolume"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updateVolume"]; ok {
			fn(c)
		}
		volumesCmd.AddCommand(c)
	}

	return cmd
}
