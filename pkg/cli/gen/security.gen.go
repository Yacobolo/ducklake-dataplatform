// Code generated by cli-gen. DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strings"

	"github.com/spf13/cobra"
)

func newSecurityCmd(client *Client) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "security",
		Short: "Manage principals, groups, grants, and access controls",
	}

	apiKeysCmd := &cobra.Command{
		Use:   "api-keys",
		Short: "Manage api-keys",
	}
	cmd.AddCommand(apiKeysCmd)

	columnMasksCmd := &cobra.Command{
		Use:   "column-masks",
		Short: "Manage column-masks",
	}
	cmd.AddCommand(columnMasksCmd)

	grantsCmd := &cobra.Command{
		Use:   "grants",
		Short: "Manage grants",
	}
	cmd.AddCommand(grantsCmd)

	groupsCmd := &cobra.Command{
		Use:   "groups",
		Short: "Manage groups",
	}
	cmd.AddCommand(groupsCmd)

	membersCmd := &cobra.Command{
		Use:   "members",
		Short: "Manage members",
	}
	cmd.AddCommand(membersCmd)

	principalsCmd := &cobra.Command{
		Use:   "principals",
		Short: "Manage principals",
	}
	cmd.AddCommand(principalsCmd)

	rowFiltersCmd := &cobra.Command{
		Use:   "row-filters",
		Short: "Manage row-filters",
	}
	cmd.AddCommand(rowFiltersCmd)

	// createGroupMember
	{
		c := &cobra.Command{
			Use:     "add <group-id>",
			Short:   "Add member to group",
			Long:    "Adds a user or nested group as a member of the specified group.",
			Example: "duck security members add <group-id> --member-id 550e8400-e29b-41d4-a716-446655440002 --member-type user",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				urlPath := "/groups/{groupId}/members"
				urlPath = strings.Replace(urlPath, "{groupId}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("member-id") {
						v, _ := cmd.Flags().GetString("member-id")
						m["member_id"] = v
					}
					if cmd.Flags().Changed("member-type") {
						v, _ := cmd.Flags().GetString("member-type")
						m["member_type"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("member-id", "", "")
		_ = c.MarkFlagRequired("member-id")
		c.Flags().String("member-type", "", "")
		_ = c.MarkFlagRequired("member-type")

		// Apply overrides
		if fn, ok := runOverrides["createGroupMember"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createGroupMember"]; ok {
			fn(c)
		}
		membersCmd.AddCommand(c)
	}

	// bindColumnMask
	{
		c := &cobra.Command{
			Use:     "bind <column-mask-id>",
			Short:   "Bind mask to principal",
			Long:    "Associates a column masking rule with a principal, so that the mask is applied when the principal queries the table.",
			Example: "duck security column-masks bind <column-mask-id> --principal-id 550e8400-e29b-41d4-a716-446655440002 --principal-type user",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				urlPath := "/column-masks/{columnMaskId}/bindings"
				urlPath = strings.Replace(urlPath, "{columnMaskId}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("principal-id") {
						v, _ := cmd.Flags().GetString("principal-id")
						m["principal_id"] = v
					}
					if cmd.Flags().Changed("principal-type") {
						v, _ := cmd.Flags().GetString("principal-type")
						m["principal_type"] = v
					}
					if cmd.Flags().Changed("see-original") {
						v, _ := cmd.Flags().GetBool("see-original")
						m["see_original"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("principal-id", "", "")
		_ = c.MarkFlagRequired("principal-id")
		c.Flags().String("principal-type", "", "")
		_ = c.MarkFlagRequired("principal-type")
		c.Flags().Bool("see-original", false, "")

		// Apply overrides
		if fn, ok := runOverrides["bindColumnMask"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["bindColumnMask"]; ok {
			fn(c)
		}
		columnMasksCmd.AddCommand(c)
	}

	// bindRowFilter
	{
		c := &cobra.Command{
			Use:     "bind <row-filter-id>",
			Short:   "Bind filter to principal",
			Long:    "Associates a row-level security filter with a principal, so that the filter is applied when the principal queries the table.",
			Example: "duck security row-filters bind <row-filter-id> --principal-id 550e8400-e29b-41d4-a716-446655440002 --principal-type user",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				urlPath := "/row-filters/{rowFilterId}/bindings"
				urlPath = strings.Replace(urlPath, "{rowFilterId}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("principal-id") {
						v, _ := cmd.Flags().GetString("principal-id")
						m["principal_id"] = v
					}
					if cmd.Flags().Changed("principal-type") {
						v, _ := cmd.Flags().GetString("principal-type")
						m["principal_type"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("principal-id", "", "")
		_ = c.MarkFlagRequired("principal-id")
		c.Flags().String("principal-type", "", "")
		_ = c.MarkFlagRequired("principal-type")

		// Apply overrides
		if fn, ok := runOverrides["bindRowFilter"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["bindRowFilter"]; ok {
			fn(c)
		}
		rowFiltersCmd.AddCommand(c)
	}

	// cleanupExpiredAPIKeys
	{
		c := &cobra.Command{
			Use:   "cleanup",
			Short: "Delete all expired API keys (admin only)",
			Long:  "Removes all API keys that have passed their expiration date. Only administrators can perform this operation.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/api-keys/cleanup"
				query := url.Values{}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["cleanupExpiredAPIKeys"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["cleanupExpiredAPIKeys"]; ok {
			fn(c)
		}
		apiKeysCmd.AddCommand(c)
	}

	// createAPIKey
	{
		c := &cobra.Command{
			Use:     "create",
			Short:   "Create a new API key",
			Long:    "Generates a new API key for the specified principal. The raw key value is returned only in this response and cannot be retrieved later.",
			Example: "duck security api-keys create --expires-at 2026-01-15T09:30:00Z --name ci-pipeline-key --principal-id 550e8400-e29b-41d4-a716-446655440002",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/api-keys"
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("expires-at") {
						v, _ := cmd.Flags().GetString("expires-at")
						m["expires_at"] = v
					}
					if cmd.Flags().Changed("name") {
						v, _ := cmd.Flags().GetString("name")
						m["name"] = v
					}
					if cmd.Flags().Changed("principal-id") {
						v, _ := cmd.Flags().GetString("principal-id")
						m["principal_id"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("expires-at", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("name", "", "")
		_ = c.MarkFlagRequired("name")
		c.Flags().String("principal-id", "", "")
		_ = c.MarkFlagRequired("principal-id")

		// Apply overrides
		if fn, ok := runOverrides["createAPIKey"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createAPIKey"]; ok {
			fn(c)
		}
		apiKeysCmd.AddCommand(c)
	}

	// createColumnMask
	{
		c := &cobra.Command{
			Use:     "create <table-id>",
			Short:   "Create column mask",
			Long:    "Creates a new column masking rule for the specified table. The mask expression defines how column values are transformed.",
			Example: "duck security column-masks create <table-id> --column-name email --description \"Mask email local part\" --mask-expression \"'***@' || split_part(email, '@', 2)\"",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/tables/{tableId}/column-masks"
				urlPath = strings.Replace(urlPath, "{tableId}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("column-name") {
						v, _ := cmd.Flags().GetString("column-name")
						m["column_name"] = v
					}
					if cmd.Flags().Changed("description") {
						v, _ := cmd.Flags().GetString("description")
						m["description"] = v
					}
					if cmd.Flags().Changed("mask-expression") {
						v, _ := cmd.Flags().GetString("mask-expression")
						m["mask_expression"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("column-name", "", "")
		_ = c.MarkFlagRequired("column-name")
		c.Flags().String("description", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("mask-expression", "", "")
		_ = c.MarkFlagRequired("mask-expression")

		// Apply overrides
		if fn, ok := runOverrides["createColumnMask"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createColumnMask"]; ok {
			fn(c)
		}
		columnMasksCmd.AddCommand(c)
	}

	// createGrant
	{
		c := &cobra.Command{
			Use:     "create",
			Short:   "Grant a privilege",
			Long:    "Creates a new privilege grant for a principal on a securable resource. Returns the created grant.",
			Example: "duck security grants create --principal-id 550e8400-e29b-41d4-a716-446655440002 --principal-type user --privilege USE_SCHEMA --securable-id 550e8400-e29b-41d4-a716-446655440001 --securable-type schema",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/grants"
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("principal-id") {
						v, _ := cmd.Flags().GetString("principal-id")
						m["principal_id"] = v
					}
					if cmd.Flags().Changed("principal-type") {
						v, _ := cmd.Flags().GetString("principal-type")
						m["principal_type"] = v
					}
					if cmd.Flags().Changed("privilege") {
						v, _ := cmd.Flags().GetString("privilege")
						m["privilege"] = v
					}
					if cmd.Flags().Changed("securable-id") {
						v, _ := cmd.Flags().GetString("securable-id")
						m["securable_id"] = v
					}
					if cmd.Flags().Changed("securable-type") {
						v, _ := cmd.Flags().GetString("securable-type")
						m["securable_type"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("principal-id", "", "")
		_ = c.MarkFlagRequired("principal-id")
		c.Flags().String("principal-type", "", "")
		_ = c.MarkFlagRequired("principal-type")
		c.Flags().String("privilege", "", "")
		_ = c.MarkFlagRequired("privilege")
		c.Flags().String("securable-id", "", "")
		_ = c.MarkFlagRequired("securable-id")
		c.Flags().String("securable-type", "", "")
		_ = c.MarkFlagRequired("securable-type")

		// Apply overrides
		if fn, ok := runOverrides["createGrant"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createGrant"]; ok {
			fn(c)
		}
		grantsCmd.AddCommand(c)
	}

	// createGroup
	{
		c := &cobra.Command{
			Use:     "create <name>",
			Short:   "Create a group",
			Long:    "Creates a new group with the specified name. Returns the created group with its generated identifier.",
			Example: "duck security groups create engineering --description \"Engineering team\"",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/groups"
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("description") {
						v, _ := cmd.Flags().GetString("description")
						m["description"] = v
					}
					m["name"] = args[0]
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("description", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")

		// Apply overrides
		if fn, ok := runOverrides["createGroup"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createGroup"]; ok {
			fn(c)
		}
		groupsCmd.AddCommand(c)
	}

	// createPrincipal
	{
		c := &cobra.Command{
			Use:     "create <name>",
			Short:   "Create a principal",
			Long:    "Creates a new principal with the specified name and optional type. Returns the created principal with its generated identifier.",
			Example: "duck security principals create alice --type user",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/principals"
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("is-admin") {
						v, _ := cmd.Flags().GetBool("is-admin")
						m["is_admin"] = v
					}
					if cmd.Flags().Changed("type") {
						v, _ := cmd.Flags().GetString("type")
						m["type"] = v
					}
					m["name"] = args[0]
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().Bool("is-admin", false, "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("type", "user", "")

		// Apply overrides
		if fn, ok := runOverrides["createPrincipal"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createPrincipal"]; ok {
			fn(c)
		}
		principalsCmd.AddCommand(c)
	}

	// createRowFilter
	{
		c := &cobra.Command{
			Use:     "create <table-id>",
			Short:   "Create row filter",
			Long:    "Creates a new row-level security filter for the specified table. The filter expression defines which rows are visible.",
			Example: "duck security row-filters create <table-id> --description \"Restrict to US East region\" --filter-sql \"region = 'us-east-1'\" --table-id 550e8400-e29b-41d4-a716-446655440005",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/tables/{tableId}/row-filters"
				urlPath = strings.Replace(urlPath, "{tableId}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("description") {
						v, _ := cmd.Flags().GetString("description")
						m["description"] = v
					}
					if cmd.Flags().Changed("filter-sql") {
						v, _ := cmd.Flags().GetString("filter-sql")
						m["filter_sql"] = v
					}
					if cmd.Flags().Changed("table-id") {
						v, _ := cmd.Flags().GetString("table-id")
						m["table_id"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("description", "", "")
		c.Flags().String("filter-sql", "", "")
		_ = c.MarkFlagRequired("filter-sql")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("table-id", "", "Table ID (required when creating via top-level POST /row-filters)")

		// Apply overrides
		if fn, ok := runOverrides["createRowFilter"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createRowFilter"]; ok {
			fn(c)
		}
		rowFiltersCmd.AddCommand(c)
	}

	// deleteAPIKey
	{
		c := &cobra.Command{
			Use:     "delete <api-key-id>",
			Short:   "Delete an API key",
			Long:    "Permanently deletes an API key, immediately revoking access for any client using it.",
			Example: "duck security api-keys delete <api-key-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/api-keys/{apiKeyId}"
				urlPath = strings.Replace(urlPath, "{apiKeyId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteAPIKey"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteAPIKey"]; ok {
			fn(c)
		}
		apiKeysCmd.AddCommand(c)
	}

	// deleteColumnMask
	{
		c := &cobra.Command{
			Use:     "delete <column-mask-id>",
			Short:   "Delete column mask",
			Long:    "Permanently removes a column masking rule and all its principal bindings.",
			Example: "duck security column-masks delete <column-mask-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/column-masks/{columnMaskId}"
				urlPath = strings.Replace(urlPath, "{columnMaskId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteColumnMask"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteColumnMask"]; ok {
			fn(c)
		}
		columnMasksCmd.AddCommand(c)
	}

	// deleteGroup
	{
		c := &cobra.Command{
			Use:     "delete <group-id>",
			Short:   "Delete a group",
			Long:    "Permanently removes a group from the system. All memberships and associated grants are also removed.",
			Example: "duck security groups delete <group-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/groups/{groupId}"
				urlPath = strings.Replace(urlPath, "{groupId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteGroup"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteGroup"]; ok {
			fn(c)
		}
		groupsCmd.AddCommand(c)
	}

	// deletePrincipal
	{
		c := &cobra.Command{
			Use:     "delete <principal-id>",
			Short:   "Delete a principal",
			Long:    "Permanently removes a principal from the system. Associated grants and group memberships are also removed.",
			Example: "duck security principals delete <principal-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/principals/{principalId}"
				urlPath = strings.Replace(urlPath, "{principalId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deletePrincipal"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deletePrincipal"]; ok {
			fn(c)
		}
		principalsCmd.AddCommand(c)
	}

	// deleteRowFilter
	{
		c := &cobra.Command{
			Use:     "delete <row-filter-id>",
			Short:   "Delete row filter",
			Long:    "Permanently removes a row-level security filter and all its principal bindings.",
			Example: "duck security row-filters delete <row-filter-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/row-filters/{rowFilterId}"
				urlPath = strings.Replace(urlPath, "{rowFilterId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteRowFilter"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteRowFilter"]; ok {
			fn(c)
		}
		rowFiltersCmd.AddCommand(c)
	}

	// getGroup
	{
		c := &cobra.Command{
			Use:     "get <group-id>",
			Short:   "Get group by ID",
			Long:    "Retrieves the details of a specific group by its unique identifier.",
			Example: "duck security groups get <group-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/groups/{groupId}"
				urlPath = strings.Replace(urlPath, "{groupId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["getGroup"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getGroup"]; ok {
			fn(c)
		}
		groupsCmd.AddCommand(c)
	}

	// getPrincipal
	{
		c := &cobra.Command{
			Use:     "get <principal-id>",
			Short:   "Get principal by ID",
			Long:    "Retrieves the details of a specific principal by its unique identifier.",
			Example: "duck security principals get <principal-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/principals/{principalId}"
				urlPath = strings.Replace(urlPath, "{principalId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["getPrincipal"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getPrincipal"]; ok {
			fn(c)
		}
		principalsCmd.AddCommand(c)
	}

	// listAPIKeys
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List API keys for a principal",
			Long:  "Returns a paginated list of API keys associated with the specified principal. Raw key values are not included.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/api-keys"
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}
				if cmd.Flags().Changed("principal-id") {
					v, _ := cmd.Flags().GetString("principal-id")
					query.Set("principal_id", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "principal_id", "name", "key_prefix", "expires_at", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")
		c.Flags().String("principal-id", "", "Filter by principal identifier.")
		_ = c.MarkFlagRequired("principal-id")

		// Apply overrides
		if fn, ok := runOverrides["listAPIKeys"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listAPIKeys"]; ok {
			fn(c)
		}
		apiKeysCmd.AddCommand(c)
	}

	// listColumnMasks
	{
		c := &cobra.Command{
			Use:     "list <table-id>",
			Short:   "List column masks",
			Long:    "Returns a paginated list of all column masking rules defined for the specified table.",
			Example: "duck security column-masks list <table-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/tables/{tableId}/column-masks"
				urlPath = strings.Replace(urlPath, "{tableId}", args[0], 1)
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "table_id", "column_name", "mask_expression", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listColumnMasks"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listColumnMasks"]; ok {
			fn(c)
		}
		columnMasksCmd.AddCommand(c)
	}

	// listGrants
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List grants",
			Long:  "Returns a paginated list of privilege grants, optionally filtered by principal or securable.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/grants"
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}
				if cmd.Flags().Changed("principal-id") {
					v, _ := cmd.Flags().GetString("principal-id")
					query.Set("principal_id", v)
				}
				if cmd.Flags().Changed("principal-type") {
					v, _ := cmd.Flags().GetString("principal-type")
					query.Set("principal_type", v)
				}
				if cmd.Flags().Changed("securable-id") {
					v, _ := cmd.Flags().GetString("securable-id")
					query.Set("securable_id", v)
				}
				if cmd.Flags().Changed("securable-type") {
					v, _ := cmd.Flags().GetString("securable-type")
					query.Set("securable_type", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "principal_id", "principal_type", "securable_type", "privilege", "granted_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")
		c.Flags().String("principal-id", "", "Filter by principal identifier.")
		c.Flags().String("principal-type", "", "Filter by principal type.")
		c.Flags().String("securable-id", "", "Filter by securable resource identifier.")
		c.Flags().String("securable-type", "", "Filter by securable resource type.")

		// Apply overrides
		if fn, ok := runOverrides["listGrants"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listGrants"]; ok {
			fn(c)
		}
		grantsCmd.AddCommand(c)
	}

	// listGroupMembers
	{
		c := &cobra.Command{
			Use:     "list <group-id>",
			Short:   "List group members",
			Long:    "Returns a paginated list of all members (users and nested groups) belonging to the specified group.",
			Example: "duck security members list <group-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/groups/{groupId}/members"
				urlPath = strings.Replace(urlPath, "{groupId}", args[0], 1)
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"group_id", "member_type", "member_id"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listGroupMembers"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listGroupMembers"]; ok {
			fn(c)
		}
		membersCmd.AddCommand(c)
	}

	// listGroups
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List all groups",
			Long:  "Returns a paginated list of all groups defined in the system.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/groups"
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "name", "description", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listGroups"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listGroups"]; ok {
			fn(c)
		}
		groupsCmd.AddCommand(c)
	}

	// listPrincipals
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List all principals",
			Long:  "Returns a paginated list of all principals (users and service accounts) in the system.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/principals"
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "name", "type", "is_admin", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listPrincipals"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listPrincipals"]; ok {
			fn(c)
		}
		principalsCmd.AddCommand(c)
	}

	// listRowFilters
	{
		c := &cobra.Command{
			Use:     "list <table-id>",
			Short:   "List row filters for table",
			Long:    "Returns a paginated list of all row-level security filters defined for the specified table.",
			Example: "duck security row-filters list <table-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/tables/{tableId}/row-filters"
				urlPath = strings.Replace(urlPath, "{tableId}", args[0], 1)
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "table_id", "filter_sql", "description", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listRowFilters"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listRowFilters"]; ok {
			fn(c)
		}
		rowFiltersCmd.AddCommand(c)
	}

	// deleteGroupMember
	{
		c := &cobra.Command{
			Use:     "remove <group-id>",
			Short:   "Remove member from group",
			Long:    "Removes a specific user or nested group from the specified group.",
			Example: "duck security members remove <group-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				urlPath := "/groups/{groupId}/members"
				urlPath = strings.Replace(urlPath, "{groupId}", args[0], 1)
				query := url.Values{}
				if cmd.Flags().Changed("member-id") {
					v, _ := cmd.Flags().GetString("member-id")
					query.Set("member_id", v)
				}
				if cmd.Flags().Changed("member-type") {
					v, _ := cmd.Flags().GetString("member-type")
					query.Set("member_type", v)
				}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().String("member-id", "", "Identifier of the member to remove.")
		_ = c.MarkFlagRequired("member-id")
		c.Flags().String("member-type", "", "Type of the group member (user or group).")
		_ = c.MarkFlagRequired("member-type")

		// Apply overrides
		if fn, ok := runOverrides["deleteGroupMember"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteGroupMember"]; ok {
			fn(c)
		}
		membersCmd.AddCommand(c)
	}

	// deleteGrant
	{
		c := &cobra.Command{
			Use:     "revoke <grant-id>",
			Short:   "Revoke a privilege",
			Long:    "Revokes a previously granted privilege by deleting the grant record.",
			Example: "duck security grants revoke <grant-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				urlPath := "/grants/{grantId}"
				urlPath = strings.Replace(urlPath, "{grantId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["deleteGrant"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteGrant"]; ok {
			fn(c)
		}
		grantsCmd.AddCommand(c)
	}

	// updatePrincipalAdmin
	{
		c := &cobra.Command{
			Use:     "set-admin <principal-id>",
			Short:   "Set or unset admin flag",
			Long:    "Updates the admin status of a principal. Only existing admins can promote or demote other principals.",
			Example: "duck security principals set-admin <principal-id> --is-admin",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				urlPath := "/principals/{principalId}/admin"
				urlPath = strings.Replace(urlPath, "{principalId}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("is-admin") {
						v, _ := cmd.Flags().GetBool("is-admin")
						m["is_admin"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PUT", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("is-admin", false, "")
		_ = c.MarkFlagRequired("is-admin")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")

		// Apply overrides
		if fn, ok := runOverrides["updatePrincipalAdmin"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updatePrincipalAdmin"]; ok {
			fn(c)
		}
		principalsCmd.AddCommand(c)
	}

	// unbindColumnMask
	{
		c := &cobra.Command{
			Use:     "unbind <column-mask-id>",
			Short:   "Unbind mask from principal",
			Long:    "Removes the association between a column masking rule and a principal.",
			Example: "duck security column-masks unbind <column-mask-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				urlPath := "/column-masks/{columnMaskId}/bindings"
				urlPath = strings.Replace(urlPath, "{columnMaskId}", args[0], 1)
				query := url.Values{}
				if cmd.Flags().Changed("principal-id") {
					v, _ := cmd.Flags().GetString("principal-id")
					query.Set("principal_id", v)
				}
				if cmd.Flags().Changed("principal-type") {
					v, _ := cmd.Flags().GetString("principal-type")
					query.Set("principal_type", v)
				}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().String("principal-id", "", "Filter by principal identifier.")
		_ = c.MarkFlagRequired("principal-id")
		c.Flags().String("principal-type", "", "Filter by principal type.")
		_ = c.MarkFlagRequired("principal-type")

		// Apply overrides
		if fn, ok := runOverrides["unbindColumnMask"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["unbindColumnMask"]; ok {
			fn(c)
		}
		columnMasksCmd.AddCommand(c)
	}

	// unbindRowFilter
	{
		c := &cobra.Command{
			Use:     "unbind <row-filter-id>",
			Short:   "Unbind filter from principal",
			Long:    "Removes the association between a row-level security filter and a principal.",
			Example: "duck security row-filters unbind <row-filter-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				urlPath := "/row-filters/{rowFilterId}/bindings"
				urlPath = strings.Replace(urlPath, "{rowFilterId}", args[0], 1)
				query := url.Values{}
				if cmd.Flags().Changed("principal-id") {
					v, _ := cmd.Flags().GetString("principal-id")
					query.Set("principal_id", v)
				}
				if cmd.Flags().Changed("principal-type") {
					v, _ := cmd.Flags().GetString("principal-type")
					query.Set("principal_type", v)
				}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().String("principal-id", "", "Filter by principal identifier.")
		_ = c.MarkFlagRequired("principal-id")
		c.Flags().String("principal-type", "", "Filter by principal type.")
		_ = c.MarkFlagRequired("principal-type")

		// Apply overrides
		if fn, ok := runOverrides["unbindRowFilter"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["unbindRowFilter"]; ok {
			fn(c)
		}
		rowFiltersCmd.AddCommand(c)
	}

	return cmd
}
