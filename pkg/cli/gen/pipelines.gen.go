// Code generated by cli-gen. DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strings"

	"github.com/spf13/cobra"
)

func newPipelinesCmd(client *Client) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "pipelines",
		Short: "Manage pipelines, jobs, and runs",
	}

	jobRunsCmd := &cobra.Command{
		Use:   "job-runs",
		Short: "Manage job-runs",
	}
	cmd.AddCommand(jobRunsCmd)

	jobsCmd := &cobra.Command{
		Use:   "jobs",
		Short: "Manage jobs",
	}
	cmd.AddCommand(jobsCmd)

	runsCmd := &cobra.Command{
		Use:   "runs",
		Short: "Manage runs",
	}
	cmd.AddCommand(runsCmd)

	// cancelPipelineRun
	{
		c := &cobra.Command{
			Use:     "cancel <run-id>",
			Short:   "Cancel a pipeline run",
			Long:    "Cancels a running or pending pipeline run.",
			Example: "duck pipelines runs cancel <run-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines/runs/{runId}/cancel"
				urlPath = strings.Replace(urlPath, "{runId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["cancelPipelineRun"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["cancelPipelineRun"]; ok {
			fn(c)
		}
		runsCmd.AddCommand(c)
	}

	// createPipelineJob
	{
		c := &cobra.Command{
			Use:     "create <pipeline-name>",
			Short:   "Create a job in a pipeline",
			Long:    "Creates a new job within a pipeline.",
			Example: "duck pipelines jobs create <pipeline-name> --compute-endpoint-id 550e8400-e29b-41d4-a716-446655440020 --job-order 0 --name extract-data --notebook-id 550e8400-e29b-41d4-a716-446655440030 --retry-count 2 --timeout-seconds 3600",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines/{pipelineName}/jobs"
				urlPath = strings.Replace(urlPath, "{pipelineName}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("compute-endpoint-id") {
						v, _ := cmd.Flags().GetString("compute-endpoint-id")
						m["compute_endpoint_id"] = v
					}
					if cmd.Flags().Changed("depends-on") {
						v, _ := cmd.Flags().GetStringSlice("depends-on")
						m["depends_on"] = v
					}
					if cmd.Flags().Changed("job-order") {
						v, _ := cmd.Flags().GetInt64("job-order")
						m["job_order"] = v
					}
					if cmd.Flags().Changed("name") {
						v, _ := cmd.Flags().GetString("name")
						m["name"] = v
					}
					if cmd.Flags().Changed("notebook-id") {
						v, _ := cmd.Flags().GetString("notebook-id")
						m["notebook_id"] = v
					}
					if cmd.Flags().Changed("retry-count") {
						v, _ := cmd.Flags().GetInt64("retry-count")
						m["retry_count"] = v
					}
					if cmd.Flags().Changed("timeout-seconds") {
						v, _ := cmd.Flags().GetInt64("timeout-seconds")
						m["timeout_seconds"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("compute-endpoint-id", "", "")
		c.Flags().StringSlice("depends-on", nil, "")
		c.Flags().Int64("job-order", 0, "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("name", "", "")
		_ = c.MarkFlagRequired("name")
		c.Flags().String("notebook-id", "", "")
		_ = c.MarkFlagRequired("notebook-id")
		c.Flags().Int64("retry-count", 0, "")
		c.Flags().Int64("timeout-seconds", 0, "")

		// Apply overrides
		if fn, ok := runOverrides["createPipelineJob"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createPipelineJob"]; ok {
			fn(c)
		}
		jobsCmd.AddCommand(c)
	}

	// createPipeline
	{
		c := &cobra.Command{
			Use:     "create",
			Short:   "Create a pipeline",
			Long:    "Creates a new pipeline workflow definition.",
			Example: "duck pipelines create --concurrency-limit 1 --description \"Daily ETL pipeline\" --name daily-etl --schedule-cron \"0 2 * * *\"",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines"
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("concurrency-limit") {
						v, _ := cmd.Flags().GetInt64("concurrency-limit")
						m["concurrency_limit"] = v
					}
					if cmd.Flags().Changed("description") {
						v, _ := cmd.Flags().GetString("description")
						m["description"] = v
					}
					if cmd.Flags().Changed("is-paused") {
						v, _ := cmd.Flags().GetBool("is-paused")
						m["is_paused"] = v
					}
					if cmd.Flags().Changed("name") {
						v, _ := cmd.Flags().GetString("name")
						m["name"] = v
					}
					if cmd.Flags().Changed("schedule-cron") {
						v, _ := cmd.Flags().GetString("schedule-cron")
						m["schedule_cron"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().Int64("concurrency-limit", 1, "")
		c.Flags().String("description", "", "")
		c.Flags().Bool("is-paused", false, "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("name", "", "")
		_ = c.MarkFlagRequired("name")
		c.Flags().String("schedule-cron", "", "")

		// Apply overrides
		if fn, ok := runOverrides["createPipeline"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createPipeline"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	// deletePipelineJob
	{
		c := &cobra.Command{
			Use:     "delete <pipeline-name> <job-id>",
			Short:   "Delete a pipeline job",
			Long:    "Removes a job from a pipeline.",
			Example: "duck pipelines jobs delete <pipeline-name> <job-id>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/pipelines/{pipelineName}/jobs/{jobId}"
				urlPath = strings.Replace(urlPath, "{pipelineName}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{jobId}", args[1], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deletePipelineJob"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deletePipelineJob"]; ok {
			fn(c)
		}
		jobsCmd.AddCommand(c)
	}

	// deletePipeline
	{
		c := &cobra.Command{
			Use:     "delete <pipeline-name>",
			Short:   "Delete a pipeline",
			Long:    "Deletes a pipeline and all its associated jobs.",
			Example: "duck pipelines delete <pipeline-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/pipelines/{pipelineName}"
				urlPath = strings.Replace(urlPath, "{pipelineName}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deletePipeline"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deletePipeline"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	// getPipeline
	{
		c := &cobra.Command{
			Use:     "get <pipeline-name>",
			Short:   "Get a pipeline by name",
			Long:    "Retrieves the details of a specific pipeline identified by its name.",
			Example: "duck pipelines get <pipeline-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines/{pipelineName}"
				urlPath = strings.Replace(urlPath, "{pipelineName}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["getPipeline"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getPipeline"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	// getPipelineRun
	{
		c := &cobra.Command{
			Use:     "get <run-id>",
			Short:   "Get a pipeline run",
			Long:    "Retrieves the details of a specific pipeline run.",
			Example: "duck pipelines runs get <run-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines/runs/{runId}"
				urlPath = strings.Replace(urlPath, "{runId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["getPipelineRun"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getPipelineRun"]; ok {
			fn(c)
		}
		runsCmd.AddCommand(c)
	}

	// listPipelineJobRuns
	{
		c := &cobra.Command{
			Use:     "list <run-id>",
			Short:   "List job runs for a pipeline run",
			Long:    "Returns the list of individual job executions within a pipeline run.",
			Example: "duck pipelines job-runs list <run-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines/runs/{runId}/jobs"
				urlPath = strings.Replace(urlPath, "{runId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["listPipelineJobRuns"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listPipelineJobRuns"]; ok {
			fn(c)
		}
		jobRunsCmd.AddCommand(c)
	}

	// listPipelineJobs
	{
		c := &cobra.Command{
			Use:     "list <pipeline-name>",
			Short:   "List jobs for a pipeline",
			Long:    "Returns the list of jobs defined in a pipeline.",
			Example: "duck pipelines jobs list <pipeline-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines/{pipelineName}/jobs"
				urlPath = strings.Replace(urlPath, "{pipelineName}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["listPipelineJobs"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listPipelineJobs"]; ok {
			fn(c)
		}
		jobsCmd.AddCommand(c)
	}

	// listPipelines
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List pipelines",
			Long:  "Returns a paginated list of pipelines.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines"
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "name", "schedule_cron", "is_paused", "created_by", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listPipelines"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listPipelines"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	// listPipelineRuns
	{
		c := &cobra.Command{
			Use:     "list <pipeline-name>",
			Short:   "List runs for a pipeline",
			Long:    "Returns a paginated list of runs for the specified pipeline.",
			Example: "duck pipelines runs list <pipeline-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines/{pipelineName}/runs"
				urlPath = strings.Replace(urlPath, "{pipelineName}", args[0], 1)
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}
				if cmd.Flags().Changed("status") {
					v, _ := cmd.Flags().GetString("status")
					query.Set("status", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "status", "trigger_type", "triggered_by", "started_at", "finished_at", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")
		c.Flags().String("status", "", "Filter runs by status.")

		// Apply overrides
		if fn, ok := runOverrides["listPipelineRuns"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listPipelineRuns"]; ok {
			fn(c)
		}
		runsCmd.AddCommand(c)
	}

	// triggerPipelineRun
	{
		c := &cobra.Command{
			Use:     "trigger <pipeline-name>",
			Short:   "Trigger a pipeline run",
			Long:    "Manually triggers a new run of the specified pipeline.",
			Example: "duck pipelines runs trigger <pipeline-name> --parameters env=production",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines/{pipelineName}/runs"
				urlPath = strings.Replace(urlPath, "{pipelineName}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("parameters") {
						v, _ := cmd.Flags().GetStringSlice("parameters")
						m["parameters"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().StringSlice("parameters", nil, "parameters (key=value pairs)")

		// Apply overrides
		if fn, ok := runOverrides["triggerPipelineRun"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["triggerPipelineRun"]; ok {
			fn(c)
		}
		runsCmd.AddCommand(c)
	}

	// updatePipeline
	{
		c := &cobra.Command{
			Use:     "update <pipeline-name>",
			Short:   "Update a pipeline",
			Long:    "Updates pipeline fields.",
			Example: "duck pipelines update <pipeline-name> --description \"Updated daily ETL pipeline\" --is-paused --schedule-cron \"0 3 * * *\"",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/pipelines/{pipelineName}"
				urlPath = strings.Replace(urlPath, "{pipelineName}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("concurrency-limit") {
						v, _ := cmd.Flags().GetInt64("concurrency-limit")
						m["concurrency_limit"] = v
					}
					if cmd.Flags().Changed("description") {
						v, _ := cmd.Flags().GetString("description")
						m["description"] = v
					}
					if cmd.Flags().Changed("is-paused") {
						v, _ := cmd.Flags().GetBool("is-paused")
						m["is_paused"] = v
					}
					if cmd.Flags().Changed("schedule-cron") {
						v, _ := cmd.Flags().GetString("schedule-cron")
						m["schedule_cron"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().Int64("concurrency-limit", 0, "")
		c.Flags().String("description", "", "")
		c.Flags().Bool("is-paused", false, "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("schedule-cron", "", "")

		// Apply overrides
		if fn, ok := runOverrides["updatePipeline"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updatePipeline"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	return cmd
}
