// Code generated by cli-gen. DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strings"

	"github.com/spf13/cobra"
)

func newStorageCmd(client *Client) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "storage",
		Short: "Storage credentials and external locations",
	}

	credentialsCmd := &cobra.Command{
		Use:   "credentials",
		Short: "Manage credentials",
	}
	cmd.AddCommand(credentialsCmd)

	locationsCmd := &cobra.Command{
		Use:   "locations",
		Short: "Manage locations",
	}
	cmd.AddCommand(locationsCmd)

	// createStorageCredential
	{
		c := &cobra.Command{
			Use:     "create <name>",
			Short:   "Create a storage credential",
			Long:    "Creates a new storage credential. Requires ALL_PRIVILEGES on catalog.",
			Example: "duck storage credentials create aws-prod-creds --credential-type S3 --endpoint s3.amazonaws.com --key-id AKIAIOSFODNN7EXAMPLE --region us-east-1 --secret wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY --url-style path",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/storage-credentials"
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("azure-account-key") {
						v, _ := cmd.Flags().GetString("azure-account-key")
						m["azure_account_key"] = v
					}
					if cmd.Flags().Changed("azure-account-name") {
						v, _ := cmd.Flags().GetString("azure-account-name")
						m["azure_account_name"] = v
					}
					if cmd.Flags().Changed("azure-client-id") {
						v, _ := cmd.Flags().GetString("azure-client-id")
						m["azure_client_id"] = v
					}
					if cmd.Flags().Changed("azure-client-secret") {
						v, _ := cmd.Flags().GetString("azure-client-secret")
						m["azure_client_secret"] = v
					}
					if cmd.Flags().Changed("azure-tenant-id") {
						v, _ := cmd.Flags().GetString("azure-tenant-id")
						m["azure_tenant_id"] = v
					}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("credential-type") {
						v, _ := cmd.Flags().GetString("credential-type")
						m["credential_type"] = v
					}
					if cmd.Flags().Changed("endpoint") {
						v, _ := cmd.Flags().GetString("endpoint")
						m["endpoint"] = v
					}
					if cmd.Flags().Changed("gcs-key-file-path") {
						v, _ := cmd.Flags().GetString("gcs-key-file-path")
						m["gcs_key_file_path"] = v
					}
					if cmd.Flags().Changed("key-id") {
						v, _ := cmd.Flags().GetString("key-id")
						m["key_id"] = v
					}
					if cmd.Flags().Changed("region") {
						v, _ := cmd.Flags().GetString("region")
						m["region"] = v
					}
					if cmd.Flags().Changed("secret") {
						v, _ := cmd.Flags().GetString("secret")
						m["secret"] = v
					}
					if cmd.Flags().Changed("url-style") {
						v, _ := cmd.Flags().GetString("url-style")
						m["url_style"] = v
					}
					m["name"] = args[0]
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Try common ID fields
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("azure-account-key", "", "")
		c.Flags().String("azure-account-name", "", "")
		c.Flags().String("azure-client-id", "", "")
		c.Flags().String("azure-client-secret", "", "")
		c.Flags().String("azure-tenant-id", "", "")
		c.Flags().String("comment", "", "")
		c.Flags().String("credential-type", "", "")
		_ = c.MarkFlagRequired("credential-type")
		c.Flags().String("endpoint", "", "")
		c.Flags().String("gcs-key-file-path", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("key-id", "", "")
		c.Flags().String("region", "", "")
		c.Flags().String("secret", "", "")
		c.Flags().String("url-style", "path", "")

		// Apply overrides
		if fn, ok := runOverrides["createStorageCredential"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createStorageCredential"]; ok {
			fn(c)
		}
		credentialsCmd.AddCommand(c)
	}

	// createExternalLocation
	{
		c := &cobra.Command{
			Use:     "create <name>",
			Short:   "Create an external location",
			Long:    "Creates a new external location and configures DuckDB with the associated credential. If this is the first location, the DuckLake catalog is attached. Requires ALL_PRIVILEGES on catalog.\n",
			Example: "duck storage locations create prod-datalake --comment \"Production data lake\" --credential-name aws-prod-creds --storage-type S3 --url s3://acme-datalake/warehouse/",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/external-locations"
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("credential-name") {
						v, _ := cmd.Flags().GetString("credential-name")
						m["credential_name"] = v
					}
					if cmd.Flags().Changed("read-only") {
						v, _ := cmd.Flags().GetBool("read-only")
						m["read_only"] = v
					}
					if cmd.Flags().Changed("storage-type") {
						v, _ := cmd.Flags().GetString("storage-type")
						m["storage_type"] = v
					}
					if cmd.Flags().Changed("url") {
						v, _ := cmd.Flags().GetString("url")
						m["url"] = v
					}
					m["name"] = args[0]
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Try common ID fields
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("comment", "", "")
		c.Flags().String("credential-name", "", "")
		_ = c.MarkFlagRequired("credential-name")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().Bool("read-only", false, "")
		c.Flags().String("storage-type", "S3", "")
		c.Flags().String("url", "", "")
		_ = c.MarkFlagRequired("url")

		// Apply overrides
		if fn, ok := runOverrides["createExternalLocation"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createExternalLocation"]; ok {
			fn(c)
		}
		locationsCmd.AddCommand(c)
	}

	// deleteStorageCredential
	{
		c := &cobra.Command{
			Use:     "delete <credential-name>",
			Short:   "Delete a storage credential",
			Long:    "Deletes a credential. Requires ALL_PRIVILEGES on catalog.",
			Example: "duck storage credentials delete <credential-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/storage-credentials/{credentialName}"
				urlPath = strings.Replace(urlPath, "{credentialName}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteStorageCredential"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteStorageCredential"]; ok {
			fn(c)
		}
		credentialsCmd.AddCommand(c)
	}

	// deleteExternalLocation
	{
		c := &cobra.Command{
			Use:     "delete <location-name>",
			Short:   "Delete an external location",
			Long:    "Deletes a location and drops the associated DuckDB secret. Requires ALL_PRIVILEGES on catalog.",
			Example: "duck storage locations delete <location-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/external-locations/{locationName}"
				urlPath = strings.Replace(urlPath, "{locationName}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteExternalLocation"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteExternalLocation"]; ok {
			fn(c)
		}
		locationsCmd.AddCommand(c)
	}

	// getStorageCredential
	{
		c := &cobra.Command{
			Use:     "get <credential-name>",
			Short:   "Get a storage credential by name",
			Long:    "Returns credential metadata. Sensitive fields (key_id, secret) are never returned.",
			Example: "duck storage credentials get <credential-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/storage-credentials/{credentialName}"
				urlPath = strings.Replace(urlPath, "{credentialName}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Try common ID fields
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["getStorageCredential"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getStorageCredential"]; ok {
			fn(c)
		}
		credentialsCmd.AddCommand(c)
	}

	// getExternalLocation
	{
		c := &cobra.Command{
			Use:     "get <location-name>",
			Short:   "Get an external location by name",
			Long:    "Retrieves the details of a specific external location identified by its name.",
			Example: "duck storage locations get <location-name>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/external-locations/{locationName}"
				urlPath = strings.Replace(urlPath, "{locationName}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Try common ID fields
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["getExternalLocation"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getExternalLocation"]; ok {
			fn(c)
		}
		locationsCmd.AddCommand(c)
	}

	// listStorageCredentials
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List storage credentials",
			Long:  "Returns a paginated list of storage credentials. Sensitive fields (key_id, secret) are never returned.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/storage-credentials"
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Try common ID fields
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "name", "credential_type", "owner", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listStorageCredentials"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listStorageCredentials"]; ok {
			fn(c)
		}
		credentialsCmd.AddCommand(c)
	}

	// listExternalLocations
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List external locations",
			Long:  "Returns a paginated list of external locations configured for remote storage access.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/external-locations"
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Try common ID fields
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "name", "url", "credential_name", "owner", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listExternalLocations"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listExternalLocations"]; ok {
			fn(c)
		}
		locationsCmd.AddCommand(c)
	}

	// updateStorageCredential
	{
		c := &cobra.Command{
			Use:     "update <credential-name>",
			Short:   "Update a storage credential",
			Long:    "Updates credential fields. Requires ALL_PRIVILEGES on catalog.",
			Example: "duck storage credentials update <credential-name> --key-id AKIAIOSFODNN7RENEWED --region us-west-2 --secret newJalrXUtnFEMI/K7MDENG/bPxRfiCYNEWKEY",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/storage-credentials/{credentialName}"
				urlPath = strings.Replace(urlPath, "{credentialName}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("azure-account-key") {
						v, _ := cmd.Flags().GetString("azure-account-key")
						m["azure_account_key"] = v
					}
					if cmd.Flags().Changed("azure-account-name") {
						v, _ := cmd.Flags().GetString("azure-account-name")
						m["azure_account_name"] = v
					}
					if cmd.Flags().Changed("azure-client-id") {
						v, _ := cmd.Flags().GetString("azure-client-id")
						m["azure_client_id"] = v
					}
					if cmd.Flags().Changed("azure-client-secret") {
						v, _ := cmd.Flags().GetString("azure-client-secret")
						m["azure_client_secret"] = v
					}
					if cmd.Flags().Changed("azure-tenant-id") {
						v, _ := cmd.Flags().GetString("azure-tenant-id")
						m["azure_tenant_id"] = v
					}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("endpoint") {
						v, _ := cmd.Flags().GetString("endpoint")
						m["endpoint"] = v
					}
					if cmd.Flags().Changed("gcs-key-file-path") {
						v, _ := cmd.Flags().GetString("gcs-key-file-path")
						m["gcs_key_file_path"] = v
					}
					if cmd.Flags().Changed("key-id") {
						v, _ := cmd.Flags().GetString("key-id")
						m["key_id"] = v
					}
					if cmd.Flags().Changed("region") {
						v, _ := cmd.Flags().GetString("region")
						m["region"] = v
					}
					if cmd.Flags().Changed("secret") {
						v, _ := cmd.Flags().GetString("secret")
						m["secret"] = v
					}
					if cmd.Flags().Changed("url-style") {
						v, _ := cmd.Flags().GetString("url-style")
						m["url_style"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Try common ID fields
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("azure-account-key", "", "")
		c.Flags().String("azure-account-name", "", "")
		c.Flags().String("azure-client-id", "", "")
		c.Flags().String("azure-client-secret", "", "")
		c.Flags().String("azure-tenant-id", "", "")
		c.Flags().String("comment", "", "")
		c.Flags().String("endpoint", "", "")
		c.Flags().String("gcs-key-file-path", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("key-id", "", "")
		c.Flags().String("region", "", "")
		c.Flags().String("secret", "", "")
		c.Flags().String("url-style", "", "")

		// Apply overrides
		if fn, ok := runOverrides["updateStorageCredential"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updateStorageCredential"]; ok {
			fn(c)
		}
		credentialsCmd.AddCommand(c)
	}

	// updateExternalLocation
	{
		c := &cobra.Command{
			Use:     "update <location-name>",
			Short:   "Update an external location",
			Long:    "Updates location fields. Requires ALL_PRIVILEGES on catalog.",
			Example: "duck storage locations update <location-name> --comment \"Updated production data lake path\" --credential-name aws-prod-creds --url s3://acme-datalake/warehouse-v2/",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/external-locations/{locationName}"
				urlPath = strings.Replace(urlPath, "{locationName}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("comment") {
						v, _ := cmd.Flags().GetString("comment")
						m["comment"] = v
					}
					if cmd.Flags().Changed("credential-name") {
						v, _ := cmd.Flags().GetString("credential-name")
						m["credential_name"] = v
					}
					if cmd.Flags().Changed("owner") {
						v, _ := cmd.Flags().GetString("owner")
						m["owner"] = v
					}
					if cmd.Flags().Changed("read-only") {
						v, _ := cmd.Flags().GetBool("read-only")
						m["read_only"] = v
					}
					if cmd.Flags().Changed("url") {
						v, _ := cmd.Flags().GetString("url")
						m["url"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Try common ID fields
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("comment", "", "")
		c.Flags().String("credential-name", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("owner", "", "")
		c.Flags().Bool("read-only", false, "")
		c.Flags().String("url", "", "")

		// Apply overrides
		if fn, ok := runOverrides["updateExternalLocation"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updateExternalLocation"]; ok {
			fn(c)
		}
		locationsCmd.AddCommand(c)
	}

	return cmd
}
