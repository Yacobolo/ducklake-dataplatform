// Code generated by cli-gen. DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strings"

	"github.com/spf13/cobra"
)

func newNotebooksCmd(client *Client) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "notebooks",
		Short: "Manage notebooks, cells, sessions, and git repos",
	}

	cellsCmd := &cobra.Command{
		Use:   "cells",
		Short: "Manage cells",
	}
	cmd.AddCommand(cellsCmd)

	gitReposCmd := &cobra.Command{
		Use:   "git-repos",
		Short: "Manage git-repos",
	}
	cmd.AddCommand(gitReposCmd)

	jobsCmd := &cobra.Command{
		Use:   "jobs",
		Short: "Manage jobs",
	}
	cmd.AddCommand(jobsCmd)

	sessionsCmd := &cobra.Command{
		Use:   "sessions",
		Short: "Manage sessions",
	}
	cmd.AddCommand(sessionsCmd)

	// closeNotebookSession
	{
		c := &cobra.Command{
			Use:     "close <notebook-id> <session-id>",
			Short:   "Close a notebook session",
			Long:    "Closes the session and releases the DuckDB connection.",
			Example: "duck notebooks sessions close <notebook-id> <session-id>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				urlPath := "/notebooks/{notebookId}/sessions/{sessionId}"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{sessionId}", args[1], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["closeNotebookSession"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["closeNotebookSession"]; ok {
			fn(c)
		}
		sessionsCmd.AddCommand(c)
	}

	// createCell
	{
		c := &cobra.Command{
			Use:     "create <notebook-id>",
			Short:   "Add a cell to a notebook",
			Long:    "Creates a new cell in the specified notebook.",
			Example: "duck notebooks cells create <notebook-id> --cell-type sql --content \"SELECT * FROM sales LIMIT 10\" --position 0",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}/cells"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("cell-type") {
						v, _ := cmd.Flags().GetString("cell-type")
						m["cell_type"] = v
					}
					if cmd.Flags().Changed("content") {
						v, _ := cmd.Flags().GetString("content")
						m["content"] = v
					}
					if cmd.Flags().Changed("position") {
						v, _ := cmd.Flags().GetInt64("position")
						m["position"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("cell-type", "", "")
		_ = c.MarkFlagRequired("cell-type")
		c.Flags().String("content", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().Int64("position", 0, "Position in the notebook. If omitted, appends to end.")

		// Apply overrides
		if fn, ok := runOverrides["createCell"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createCell"]; ok {
			fn(c)
		}
		cellsCmd.AddCommand(c)
	}

	// createGitRepo
	{
		c := &cobra.Command{
			Use:     "create",
			Short:   "Register a Git repository",
			Long:    "Registers a new Git repository for notebook sync.",
			Example: "duck notebooks git-repos create --auth-token ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx --branch main --path notebooks/ --url https://github.com/example/notebooks.git",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/git-repos"
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("auth-token") {
						v, _ := cmd.Flags().GetString("auth-token")
						m["auth_token"] = v
					}
					if cmd.Flags().Changed("branch") {
						v, _ := cmd.Flags().GetString("branch")
						m["branch"] = v
					}
					if cmd.Flags().Changed("path") {
						v, _ := cmd.Flags().GetString("path")
						m["path"] = v
					}
					if cmd.Flags().Changed("url") {
						v, _ := cmd.Flags().GetString("url")
						m["url"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("auth-token", "", "Personal access token or deploy key for Git authentication.")
		_ = c.MarkFlagRequired("auth-token")
		c.Flags().String("branch", "main", "")
		_ = c.MarkFlagRequired("branch")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("path", "", "")
		c.Flags().String("url", "", "")
		_ = c.MarkFlagRequired("url")

		// Apply overrides
		if fn, ok := runOverrides["createGitRepo"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createGitRepo"]; ok {
			fn(c)
		}
		gitReposCmd.AddCommand(c)
	}

	// createNotebook
	{
		c := &cobra.Command{
			Use:     "create",
			Short:   "Create a notebook",
			Long:    "Creates a new SQL notebook.",
			Example: "duck notebooks create --description \"Quarterly sales analysis notebook\" --name \"Sales Analysis\"",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks"
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("description") {
						v, _ := cmd.Flags().GetString("description")
						m["description"] = v
					}
					if cmd.Flags().Changed("name") {
						v, _ := cmd.Flags().GetString("name")
						m["name"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("description", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("name", "", "")
		_ = c.MarkFlagRequired("name")

		// Apply overrides
		if fn, ok := runOverrides["createNotebook"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createNotebook"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	// createNotebookSession
	{
		c := &cobra.Command{
			Use:     "create <notebook-id>",
			Short:   "Start a notebook session",
			Long:    "Creates a new execution session with a pinned DuckDB connection.",
			Example: "duck notebooks sessions create <notebook-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}/sessions"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["createNotebookSession"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["createNotebookSession"]; ok {
			fn(c)
		}
		sessionsCmd.AddCommand(c)
	}

	// deleteCell
	{
		c := &cobra.Command{
			Use:     "delete <notebook-id> <cell-id>",
			Short:   "Delete a cell",
			Long:    "Deletes a cell from the notebook.",
			Example: "duck notebooks cells delete <notebook-id> <cell-id>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/notebooks/{notebookId}/cells/{cellId}"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{cellId}", args[1], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteCell"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteCell"]; ok {
			fn(c)
		}
		cellsCmd.AddCommand(c)
	}

	// deleteGitRepo
	{
		c := &cobra.Command{
			Use:     "delete <git-repo-id>",
			Short:   "Delete a Git repository",
			Long:    "Deletes a registered Git repository.",
			Example: "duck notebooks git-repos delete <git-repo-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/git-repos/{gitRepoId}"
				urlPath = strings.Replace(urlPath, "{gitRepoId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteGitRepo"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteGitRepo"]; ok {
			fn(c)
		}
		gitReposCmd.AddCommand(c)
	}

	// deleteNotebook
	{
		c := &cobra.Command{
			Use:     "delete <notebook-id>",
			Short:   "Delete a notebook",
			Long:    "Deletes a notebook and all its cells.",
			Example: "duck notebooks delete <notebook-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				if !cmd.Flags().Changed("yes") {
					if !ConfirmPrompt("Are you sure?") {
						return nil
					}
				}
				urlPath := "/notebooks/{notebookId}"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("DELETE", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				fmt.Fprintln(os.Stdout, "Done.")
				return nil
			},
		}
		c.Flags().Bool("yes", false, "Skip confirmation prompt")

		// Apply overrides
		if fn, ok := runOverrides["deleteNotebook"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["deleteNotebook"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	// executeCell
	{
		c := &cobra.Command{
			Use:     "execute <notebook-id> <session-id> <cell-id>",
			Short:   "Execute a single cell in a session",
			Long:    "Runs the cell's SQL through the RBAC/RLS pipeline on the pinned connection.",
			Example: "duck notebooks sessions execute <notebook-id> <session-id> <cell-id>",
			Args:    cobra.ExactArgs(3),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}/sessions/{sessionId}/execute/{cellId}"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{sessionId}", args[1], 1)
				urlPath = strings.Replace(urlPath, "{cellId}", args[2], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["executeCell"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["executeCell"]; ok {
			fn(c)
		}
		sessionsCmd.AddCommand(c)
	}

	// getGitRepo
	{
		c := &cobra.Command{
			Use:     "get <git-repo-id>",
			Short:   "Get a Git repository",
			Long:    "Retrieves the details of a registered Git repository.",
			Example: "duck notebooks git-repos get <git-repo-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/git-repos/{gitRepoId}"
				urlPath = strings.Replace(urlPath, "{gitRepoId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["getGitRepo"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getGitRepo"]; ok {
			fn(c)
		}
		gitReposCmd.AddCommand(c)
	}

	// getNotebookJob
	{
		c := &cobra.Command{
			Use:     "get <notebook-id> <job-id>",
			Short:   "Get job status",
			Long:    "Retrieves the status and result of a notebook job.",
			Example: "duck notebooks jobs get <notebook-id> <job-id>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}/jobs/{jobId}"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{jobId}", args[1], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["getNotebookJob"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getNotebookJob"]; ok {
			fn(c)
		}
		jobsCmd.AddCommand(c)
	}

	// getNotebook
	{
		c := &cobra.Command{
			Use:     "get <notebook-id>",
			Short:   "Get a notebook with cells",
			Long:    "Retrieves a notebook and its cells.",
			Example: "duck notebooks get <notebook-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["getNotebook"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["getNotebook"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	// listGitRepos
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List registered Git repositories",
			Long:  "Returns a paginated list of registered Git repositories.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/git-repos"
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "url", "branch", "path", "owner", "last_sync_at", "created_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listGitRepos"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listGitRepos"]; ok {
			fn(c)
		}
		gitReposCmd.AddCommand(c)
	}

	// listNotebookJobs
	{
		c := &cobra.Command{
			Use:     "list <notebook-id>",
			Short:   "List jobs for a notebook",
			Long:    "Returns a paginated list of jobs for the specified notebook.",
			Example: "duck notebooks jobs list <notebook-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}/jobs"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "notebook_id", "session_id", "state", "created_at", "updated_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listNotebookJobs"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listNotebookJobs"]; ok {
			fn(c)
		}
		jobsCmd.AddCommand(c)
	}

	// listNotebooks
	{
		c := &cobra.Command{
			Use:   "list",
			Short: "List notebooks",
			Long:  "Returns a paginated list of notebooks.",
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks"
				query := url.Values{}
				if cmd.Flags().Changed("max-results") {
					v, _ := cmd.Flags().GetInt64("max-results")
					query.Set("max_results", fmt.Sprintf("%d", v))
				}
				if cmd.Flags().Changed("owner") {
					v, _ := cmd.Flags().GetString("owner")
					query.Set("owner", v)
				}
				if cmd.Flags().Changed("page-token") {
					v, _ := cmd.Flags().GetString("page-token")
					query.Set("page_token", v)
				}

				// Execute request
				resp, err := client.Do("GET", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					columns := []string{"id", "name", "owner", "created_at", "updated_at"}
					rows := ExtractRows(data, columns)
					PrintTable(os.Stdout, columns, rows)
				}
				return nil
			},
		}
		c.Flags().Int64("max-results", 100, "Maximum number of results to return per page.")
		c.Flags().String("owner", "", "Filter by owner principal name.")
		c.Flags().String("page-token", "", "Opaque pagination token from a previous response.")

		// Apply overrides
		if fn, ok := runOverrides["listNotebooks"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["listNotebooks"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	// reorderCells
	{
		c := &cobra.Command{
			Use:     "reorder <notebook-id>",
			Short:   "Reorder cells in a notebook",
			Long:    "Reorders cells in the notebook according to the provided cell ID list.",
			Example: "duck notebooks cells reorder <notebook-id> --cell-ids 660e8400-e29b-41d4-a716-446655440010,660e8400-e29b-41d4-a716-446655440011,660e8400-e29b-41d4-a716-446655440012",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}/cells/reorder"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("cell-ids") {
						v, _ := cmd.Flags().GetStringSlice("cell-ids")
						m["cell_ids"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().StringSlice("cell-ids", nil, "")
		_ = c.MarkFlagRequired("cell-ids")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")

		// Apply overrides
		if fn, ok := runOverrides["reorderCells"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["reorderCells"]; ok {
			fn(c)
		}
		cellsCmd.AddCommand(c)
	}

	// runAllCells
	{
		c := &cobra.Command{
			Use:     "run-all <notebook-id> <session-id>",
			Short:   "Execute all SQL cells in order (synchronous)",
			Long:    "Executes all SQL cells in the notebook sequentially on the pinned connection.",
			Example: "duck notebooks sessions run-all <notebook-id> <session-id>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}/sessions/{sessionId}/run-all"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{sessionId}", args[1], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["runAllCells"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["runAllCells"]; ok {
			fn(c)
		}
		sessionsCmd.AddCommand(c)
	}

	// runAllCellsAsync
	{
		c := &cobra.Command{
			Use:     "run-all-async <notebook-id> <session-id>",
			Short:   "Start async execution of all cells",
			Long:    "Starts asynchronous execution of all SQL cells in the notebook.",
			Example: "duck notebooks sessions run-all-async <notebook-id> <session-id>",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}/sessions/{sessionId}/run-all-async"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{sessionId}", args[1], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					// Custom result: default to JSON
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				}
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["runAllCellsAsync"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["runAllCellsAsync"]; ok {
			fn(c)
		}
		sessionsCmd.AddCommand(c)
	}

	// syncGitRepo
	{
		c := &cobra.Command{
			Use:     "sync <git-repo-id>",
			Short:   "Trigger Git sync",
			Long:    "Pulls latest changes from the Git repository and syncs notebooks.",
			Example: "duck notebooks git-repos sync <git-repo-id>",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/git-repos/{gitRepoId}/sync"
				urlPath = strings.Replace(urlPath, "{gitRepoId}", args[0], 1)
				query := url.Values{}

				// Execute request
				resp, err := client.Do("POST", urlPath, query, nil)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}

		// Apply overrides
		if fn, ok := runOverrides["syncGitRepo"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["syncGitRepo"]; ok {
			fn(c)
		}
		gitReposCmd.AddCommand(c)
	}

	// updateCell
	{
		c := &cobra.Command{
			Use:     "update <notebook-id> <cell-id>",
			Short:   "Update a cell",
			Long:    "Updates the content or position of a cell.",
			Example: "duck notebooks cells update <notebook-id> <cell-id> --content \"SELECT region, SUM(amount) FROM sales GROUP BY region\" --position 1",
			Args:    cobra.ExactArgs(2),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}/cells/{cellId}"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				urlPath = strings.Replace(urlPath, "{cellId}", args[1], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("content") {
						v, _ := cmd.Flags().GetString("content")
						m["content"] = v
					}
					if cmd.Flags().Changed("position") {
						v, _ := cmd.Flags().GetInt64("position")
						m["position"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("content", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().Int64("position", 0, "")

		// Apply overrides
		if fn, ok := runOverrides["updateCell"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updateCell"]; ok {
			fn(c)
		}
		cellsCmd.AddCommand(c)
	}

	// updateNotebook
	{
		c := &cobra.Command{
			Use:     "update <notebook-id>",
			Short:   "Update notebook metadata",
			Long:    "Updates the name or description of a notebook.",
			Example: "duck notebooks update <notebook-id> --description \"Updated quarterly sales analysis notebook\" --name \"Updated Sales Analysis\"",
			Args:    cobra.ExactArgs(1),
			RunE: func(cmd *cobra.Command, args []string) error {
				outputFlag, _ := cmd.Flags().GetString("output")
				_ = outputFlag
				urlPath := "/notebooks/{notebookId}"
				urlPath = strings.Replace(urlPath, "{notebookId}", args[0], 1)
				query := url.Values{}
				// Build request body
				var body interface{}
				jsonInput, _ := cmd.Flags().GetString("json")
				if jsonInput != "" {
					var raw interface{}
					jsonData := jsonInput
					if jsonInput == "-" {
						data, err := os.ReadFile("/dev/stdin")
						if err != nil {
							return fmt.Errorf("read stdin: %w", err)
						}
						jsonData = string(data)
					} else if strings.HasPrefix(jsonInput, "@") {
						data, err := os.ReadFile(jsonInput[1:])
						if err != nil {
							return fmt.Errorf("read file: %w", err)
						}
						jsonData = string(data)
					}
					if err := json.Unmarshal([]byte(jsonData), &raw); err != nil {
						return fmt.Errorf("parse JSON input: %w", err)
					}
					body = raw
				} else {
					m := map[string]interface{}{}
					if cmd.Flags().Changed("description") {
						v, _ := cmd.Flags().GetString("description")
						m["description"] = v
					}
					if cmd.Flags().Changed("name") {
						v, _ := cmd.Flags().GetString("name")
						m["name"] = v
					}
					if len(m) > 0 {
						body = m
					}
				}

				// Execute request
				resp, err := client.Do("PATCH", urlPath, query, body)
				if err != nil {
					return err
				}
				if err := CheckError(resp); err != nil {
					return err
				}
				respBody, err := ReadBody(resp)
				if err != nil {
					return fmt.Errorf("read response: %w", err)
				}

				// Handle --quiet
				quiet, _ := cmd.Root().PersistentFlags().GetBool("quiet")
				if quiet {
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err == nil {
						// Handle paginated list responses ({"data": [...]})
						if items, ok := data["data"].([]interface{}); ok {
							for _, item := range items {
								if m, ok := item.(map[string]interface{}); ok {
									for _, key := range []string{"id", "name", "key"} {
										if v, ok := m[key]; ok {
											fmt.Fprintln(os.Stdout, v)
											break
										}
									}
								}
							}
							return nil
						}
						// Handle single resource responses
						for _, key := range []string{"id", "name", "key"} {
							if v, ok := data[key]; ok {
								fmt.Fprintln(os.Stdout, v)
								return nil
							}
						}
					}
					fmt.Fprintln(os.Stdout, string(respBody))
					return nil
				}

				switch OutputFormat(outputFlag) {
				case OutputJSON:
					var pretty interface{}
					json.Unmarshal(respBody, &pretty)
					return PrintJSON(os.Stdout, pretty)
				default:
					var data map[string]interface{}
					if err := json.Unmarshal(respBody, &data); err != nil {
						return fmt.Errorf("parse response: %w", err)
					}
					PrintDetail(os.Stdout, data)
				}
				return nil
			},
		}
		c.Flags().String("description", "", "")
		c.Flags().String("json", "", "JSON input (raw string or @filename or - for stdin)")
		c.Flags().String("name", "", "")

		// Apply overrides
		if fn, ok := runOverrides["updateNotebook"]; ok {
			c.RunE = fn(client)
		}
		if fn, ok := commandOverrides["updateNotebook"]; ok {
			fn(c)
		}
		cmd.AddCommand(c)
	}

	return cmd
}
