# Plan: HTTP API with Domain Layer, oapi-codegen, and Full Feature Set

## Goal
Build a production-grade HTTP API for the DuckDB data platform using **oapi-codegen** (Chi + strict server), a clean **domain layer** with repository interfaces, and a **service layer**. Address all 7 outstanding tasks: remove legacy policy/, multiple row filters, HTTP API, policy management CRUD, audit logging, schema introspection, and DML protection.

## Decisions
- **Router**: Chi (via oapi-codegen `chi-server`)
- **Codegen**: oapi-codegen strict server mode (typed request/response objects)
- **Auth**: JWT Bearer + API Key (header `X-API-Key`)
- **Audit**: SQLite `audit_log` table in the metastore
- **Domain types**: Separate `domain/` package (clean architecture)
- **Row filters**: Multiple per table (remove `UNIQUE(table_id)`)

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                    HTTP (Chi Router)                      │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  api/                                                │ │
│  │  - openapi.yaml (spec)                               │ │
│  │  - oapi-codegen generated: types + chi-server        │ │
│  │  - StrictServerInterface implementation (handler.go) │ │
│  └────────────────────┬────────────────────────────────┘ │
│                       │                                   │
│  ┌────────────────────▼────────────────────────────────┐ │
│  │  internal/middleware/                                │ │
│  │  - JWT validation middleware                         │ │
│  │  - API Key lookup middleware                         │ │
│  │  - Principal context propagation                     │ │
│  └────────────────────┬────────────────────────────────┘ │
│                       │                                   │
│  ┌────────────────────▼────────────────────────────────┐ │
│  │  internal/service/                                   │ │
│  │  - QueryService (wraps SecureEngine)                 │ │
│  │  - PrincipalService, GroupService, GrantService      │ │
│  │  - RowFilterService, ColumnMaskService               │ │
│  │  - IntrospectionService, AuditService                │ │
│  └────────┬───────────────────────────────┬────────────┘ │
│           │                               │               │
│  ┌────────▼────────┐           ┌─────────▼────────────┐ │
│  │  domain/         │           │  engine/              │ │
│  │  - Types         │           │  - SecureEngine       │ │
│  │  - Repository    │           │  - SQL rewriting      │ │
│  │    interfaces    │           │  - DuckDB execution   │ │
│  └────────┬────────┘           └──────────────────────┘ │
│           │                                               │
│  ┌────────▼────────────────────────────────────────────┐ │
│  │  internal/repository/                                │ │
│  │  - SQLite implementations of domain.Repository       │ │
│  │  - Uses sqlc-generated db/catalog (dbstore)          │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  db/                                                 │ │
│  │  - migrations/ (goose SQL, source of truth)          │ │
│  │  - queries/ (sqlc annotated SQL)                     │ │
│  │  - catalog/ (sqlc generated Go, package dbstore)     │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

**Dependency rule**: `domain/` imports nothing from this project. All other layers depend inward toward domain.

```
api/ → internal/service/ → domain/ (interfaces)
                         → engine/ (SecureEngine)
internal/repository/ → domain/ (implements interfaces)
                     → db/catalog/ (sqlc generated)
catalog/ → db/catalog/ (existing, for CheckPrivilege etc.)
```

---

## Directory Structure (Final)

```
duck-demo/
├── main.go                              # Wiring: DB connections, migrations, DI, HTTP server start
├── go.mod / go.sum
├── Makefile                             # Updated: add oapi-codegen, new test/build targets
├── sqlc.yaml                            # Updated: new queries for audit, api_keys
├── .env
│
├── api/                                 # NEW: OpenAPI + generated code + handlers
│   ├── openapi.yaml                     # OpenAPI 3.0 spec (source of truth)
│   ├── types.cfg.yaml                   # oapi-codegen config for types
│   ├── server.cfg.yaml                  # oapi-codegen config for chi-server + strict-server
│   ├── types.gen.go                     # Generated: API request/response types
│   ├── server.gen.go                    # Generated: Chi router + StrictServerInterface
│   └── handler.go                       # Hand-written: implements StrictServerInterface
│
├── domain/                              # NEW: Domain types + repository interfaces
│   ├── principal.go                     # Principal, Group types
│   ├── grant.go                         # PrivilegeGrant type
│   ├── row_filter.go                    # RowFilter, RowFilterBinding types
│   ├── column_mask.go                   # ColumnMask, ColumnMaskBinding types
│   ├── audit.go                         # AuditEntry type
│   ├── introspection.go                 # Schema, Table, Column types
│   ├── errors.go                        # Domain error types (NotFound, AccessDenied, etc.)
│   └── repository.go                    # All repository interfaces
│
├── internal/
│   ├── service/                         # NEW: Business logic services
│   │   ├── query.go                     # QueryService
│   │   ├── principal.go                 # PrincipalService
│   │   ├── group.go                     # GroupService
│   │   ├── grant.go                     # GrantService
│   │   ├── row_filter.go               # RowFilterService
│   │   ├── column_mask.go              # ColumnMaskService
│   │   ├── introspection.go            # IntrospectionService
│   │   └── audit.go                     # AuditService
│   │
│   ├── repository/                      # NEW: SQLite repository implementations
│   │   ├── principal.go                 # implements domain.PrincipalRepository
│   │   ├── group.go                     # implements domain.GroupRepository
│   │   ├── grant.go                     # implements domain.GrantRepository
│   │   ├── row_filter.go               # implements domain.RowFilterRepository
│   │   ├── column_mask.go              # implements domain.ColumnMaskRepository
│   │   ├── introspection.go            # implements domain.IntrospectionRepository
│   │   └── audit.go                     # implements domain.AuditRepository
│   │
│   ├── middleware/                       # NEW: Auth middleware
│   │   ├── auth.go                      # JWT + API Key validation, principal context
│   │   └── auth_test.go
│   │
│   └── mapper/                          # NEW: Type mappers
│       ├── domain_dbstore.go            # domain <-> dbstore conversions
│       └── domain_api.go               # domain <-> API types conversions
│
├── config/
│   ├── config.go                        # MODIFIED: add JWT secret, listen addr, API key settings
│   └── config_test.go
│
├── catalog/                             # MODIFIED: refactor for multiple row filters
│   ├── service.go                       # GetEffectiveRowFilters (plural), updated logic
│   ├── migrate.go                       # Updated: embed migrations 006-008
│   ├── service_test.go
│   └── migrations/                      # Updated: add 006-008
│       ├── 001-005_*.sql (existing)
│       ├── 006_create_audit_log.sql
│       ├── 007_multiple_row_filters.sql
│       └── 008_create_api_keys.sql
│
├── engine/
│   ├── engine.go                        # MODIFIED: support multiple row filters, return structured results
│   ├── engine_test.go
│   └── ducklake_test.go
│
├── sqlrewrite/
│   ├── sqlrewrite.go                    # MODIFIED: remove policy import, support multiple filters
│   └── sqlrewrite_test.go
│
├── db/
│   ├── migrations/                      # MODIFIED: add 006-008
│   ├── queries/                         # MODIFIED: add audit.sql, api_keys.sql, update row_filters.sql
│   └── catalog/                         # REGENERATED: sqlc output
│
└── policy/                              # DELETED
```

---

## Phase 1: Remove policy/ Package + Refactor sqlrewrite

**Goal**: Break the `sqlrewrite → policy` dependency and delete the legacy package.

### What to do:
1. **In `sqlrewrite/sqlrewrite.go`**: The `policy` import is used only by `RewriteQuery()` and supporting functions (`buildRuleExpr`, `operatorToSQL`, `injectFiltersIntoSelectStmt`, `injectFiltersIntoNode`, `injectFiltersIntoFromNode`, `injectFiltersIntoExpr`). These functions use `policy.RLSRule` and `policy.Op*` constants.

2. **Strategy**: Move `RLSRule`, operator constants, and `RewriteQuery` into `sqlrewrite/` as local types. This keeps the function available for existing tests while removing the cross-package dependency.
   - Define `type RLSRule struct { Table, Column, Operator string; Value interface{} }` in `sqlrewrite/`
   - Define `OpEqual = "="` etc. as constants in `sqlrewrite/`
   - Update all references from `policy.RLSRule` → `RLSRule`, `policy.OpEqual` → `OpEqual`

3. **Delete** `policy/policy.go` and `policy/policy_test.go`

4. **Update `sqlrewrite/sqlrewrite_test.go`**: Change imports from `policy.RLSRule` to `sqlrewrite.RLSRule`, `policy.OpEqual` to `sqlrewrite.OpEqual`.

### Files:
- Modify: `sqlrewrite/sqlrewrite.go`, `sqlrewrite/sqlrewrite_test.go`
- Delete: `policy/policy.go`, `policy/policy_test.go`

### Verify:
```
go build ./...
go test -race ./sqlrewrite/...
```

---

## Phase 2: Schema Migrations (006-008)

### Migration 006: audit_log table
```sql
-- +goose Up
CREATE TABLE audit_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    principal_name TEXT NOT NULL,
    action TEXT NOT NULL,              -- 'QUERY', 'GRANT', 'REVOKE', 'CREATE_FILTER', etc.
    statement_type TEXT,               -- 'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DDL'
    original_sql TEXT,
    rewritten_sql TEXT,
    tables_accessed TEXT,              -- JSON array of table names
    status TEXT NOT NULL,              -- 'ALLOWED', 'DENIED', 'ERROR'
    error_message TEXT,
    duration_ms INTEGER,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_audit_principal ON audit_log(principal_name);
CREATE INDEX idx_audit_created ON audit_log(created_at);
CREATE INDEX idx_audit_status ON audit_log(status);

-- +goose Down
DROP TABLE audit_log;
```

### Migration 007: Multiple row filters per table
```sql
-- +goose Up
-- SQLite doesn't support DROP CONSTRAINT, so recreate the table
CREATE TABLE row_filters_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    table_id INTEGER NOT NULL,
    filter_sql TEXT NOT NULL,
    description TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
    -- NOTE: no UNIQUE(table_id) — multiple filters per table allowed
);

INSERT INTO row_filters_new SELECT * FROM row_filters;
DROP TABLE row_filters;
ALTER TABLE row_filters_new RENAME TO row_filters;

-- Recreate the FK from bindings (SQLite rebuilds automatically with CASCADE)

-- +goose Down
-- Re-add the unique constraint (will fail if duplicates exist)
CREATE UNIQUE INDEX IF NOT EXISTS idx_row_filters_table ON row_filters(table_id);
```

### Migration 008: API keys table
```sql
-- +goose Up
CREATE TABLE api_keys (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    key_hash TEXT NOT NULL UNIQUE,       -- SHA-256 hash of the API key
    principal_id INTEGER NOT NULL REFERENCES principals(id) ON DELETE CASCADE,
    name TEXT NOT NULL,                   -- human-readable key name
    expires_at TEXT,                       -- NULL = never expires
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_api_keys_hash ON api_keys(key_hash);

-- +goose Down
DROP TABLE api_keys;
```

### sqlc queries to add:
- `db/queries/audit.sql`: InsertAuditLog, ListAuditLogs (with filters), CountAuditLogs
- `db/queries/api_keys.sql`: CreateAPIKey, GetAPIKeyByHash, ListAPIKeysForPrincipal, DeleteAPIKey, DeleteExpiredKeys
- `db/queries/row_filters.sql`: Update `GetRowFilterForTable` → `GetRowFiltersForTable` (`:many`), add `GetRowFiltersForTableAndPrincipal` (`:many`)

### Files:
- Create: `db/migrations/006-008_*.sql`, `catalog/migrations/006-008_*.sql` (embedded copies)
- Create: `db/queries/audit.sql`, `db/queries/api_keys.sql`
- Modify: `db/queries/row_filters.sql`
- Regenerate: `db/catalog/*.go` (run `sqlc generate`)
- Modify: `catalog/migrate.go` (embed new migrations)

### Verify:
```
make sqlc
go build ./...
```

---

## Phase 3: Domain Layer

### `domain/principal.go`
```go
type Principal struct {
    ID        int64
    Name      string
    Type      string   // "user" or "service_principal"
    IsAdmin   bool
    CreatedAt time.Time
}

type Group struct {
    ID          int64
    Name        string
    Description string
    CreatedAt   time.Time
}

type GroupMember struct {
    GroupID    int64
    MemberType string
    MemberID   int64
}
```

### `domain/grant.go`
```go
type PrivilegeGrant struct {
    ID            int64
    PrincipalID   int64
    PrincipalType string
    SecurableType string
    SecurableID   int64
    Privilege     string
    GrantedBy     *int64
    GrantedAt     time.Time
}
```

### `domain/row_filter.go`
```go
type RowFilter struct {
    ID          int64
    TableID     int64
    FilterSQL   string
    Description string
    CreatedAt   time.Time
}

type RowFilterBinding struct {
    ID            int64
    RowFilterID   int64
    PrincipalID   int64
    PrincipalType string
}
```

### `domain/column_mask.go`
```go
type ColumnMask struct {
    ID              int64
    TableID         int64
    ColumnName      string
    MaskExpression  string
    Description     string
    CreatedAt       time.Time
}

type ColumnMaskBinding struct {
    ID           int64
    ColumnMaskID int64
    PrincipalID  int64
    PrincipalType string
    SeeOriginal  bool
}
```

### `domain/audit.go`
```go
type AuditEntry struct {
    ID             int64
    PrincipalName  string
    Action         string
    StatementType  *string
    OriginalSQL    *string
    RewrittenSQL   *string
    TablesAccessed []string
    Status         string   // "ALLOWED", "DENIED", "ERROR"
    ErrorMessage   *string
    DurationMs     *int64
    CreatedAt      time.Time
}
```

### `domain/introspection.go`
```go
type Schema struct {
    ID   int64
    Name string
}

type Table struct {
    ID       int64
    SchemaID int64
    Name     string
}

type Column struct {
    ID      int64
    TableID int64
    Name    string
    Type    string
}
```

### `domain/errors.go`
```go
type NotFoundError struct{ Message string }
type AccessDeniedError struct{ Message string }
type ValidationError struct{ Message string }
type ConflictError struct{ Message string }

// All implement error interface
```

### `domain/repository.go`
```go
type PrincipalRepository interface {
    Create(ctx context.Context, p *Principal) (*Principal, error)
    GetByID(ctx context.Context, id int64) (*Principal, error)
    GetByName(ctx context.Context, name string) (*Principal, error)
    List(ctx context.Context) ([]Principal, error)
    Delete(ctx context.Context, id int64) error
    SetAdmin(ctx context.Context, id int64, isAdmin bool) error
}

type GroupRepository interface {
    Create(ctx context.Context, g *Group) (*Group, error)
    GetByID(ctx context.Context, id int64) (*Group, error)
    GetByName(ctx context.Context, name string) (*Group, error)
    List(ctx context.Context) ([]Group, error)
    Delete(ctx context.Context, id int64) error
    AddMember(ctx context.Context, m *GroupMember) error
    RemoveMember(ctx context.Context, m *GroupMember) error
    ListMembers(ctx context.Context, groupID int64) ([]GroupMember, error)
    GetGroupsForMember(ctx context.Context, memberType string, memberID int64) ([]Group, error)
}

type GrantRepository interface {
    Grant(ctx context.Context, g *PrivilegeGrant) (*PrivilegeGrant, error)
    Revoke(ctx context.Context, g *PrivilegeGrant) error
    ListForPrincipal(ctx context.Context, principalID int64, principalType string) ([]PrivilegeGrant, error)
    ListForSecurable(ctx context.Context, securableType string, securableID int64) ([]PrivilegeGrant, error)
}

type RowFilterRepository interface {
    Create(ctx context.Context, f *RowFilter) (*RowFilter, error)
    GetForTable(ctx context.Context, tableID int64) ([]RowFilter, error)
    Delete(ctx context.Context, id int64) error
    Bind(ctx context.Context, b *RowFilterBinding) error
    Unbind(ctx context.Context, b *RowFilterBinding) error
    ListBindings(ctx context.Context, filterID int64) ([]RowFilterBinding, error)
}

type ColumnMaskRepository interface {
    Create(ctx context.Context, m *ColumnMask) (*ColumnMask, error)
    GetForTable(ctx context.Context, tableID int64) ([]ColumnMask, error)
    Delete(ctx context.Context, id int64) error
    Bind(ctx context.Context, b *ColumnMaskBinding) error
    Unbind(ctx context.Context, b *ColumnMaskBinding) error
    ListBindings(ctx context.Context, maskID int64) ([]ColumnMaskBinding, error)
}

type AuditRepository interface {
    Insert(ctx context.Context, e *AuditEntry) error
    List(ctx context.Context, filter AuditFilter) ([]AuditEntry, int64, error) // entries + total count
}

type AuditFilter struct {
    PrincipalName *string
    Action        *string
    Status        *string
    Since         *time.Time
    Limit         int
    Offset        int
}

type IntrospectionRepository interface {
    ListSchemas(ctx context.Context) ([]Schema, error)
    ListTables(ctx context.Context, schemaID int64) ([]Table, error)
    GetTable(ctx context.Context, tableID int64) (*Table, error)
    ListColumns(ctx context.Context, tableID int64) ([]Column, error)
}
```

### Files:
- Create: `domain/principal.go`, `domain/grant.go`, `domain/row_filter.go`, `domain/column_mask.go`, `domain/audit.go`, `domain/introspection.go`, `domain/errors.go`, `domain/repository.go`

### Verify:
```
go build ./domain/...
```

---

## Phase 4: Repository Implementations

Each file in `internal/repository/` implements one domain repository interface using sqlc-generated `dbstore.Queries`.

### Pattern (example for PrincipalRepository):
```go
package repository

type PrincipalRepo struct {
    q  *dbstore.Queries
    db *sql.DB
}

func NewPrincipalRepo(db *sql.DB) *PrincipalRepo {
    return &PrincipalRepo{q: dbstore.New(db), db: db}
}

func (r *PrincipalRepo) Create(ctx context.Context, p *domain.Principal) (*domain.Principal, error) {
    row, err := r.q.CreatePrincipal(ctx, dbstore.CreatePrincipalParams{
        Name:    p.Name,
        Type:    p.Type,
        IsAdmin: boolToInt(p.IsAdmin),
    })
    if err != nil { return nil, mapDBError(err) }
    return mapper.PrincipalFromDB(row), nil
}
// ... other methods
```

### Mapper pattern (`internal/mapper/domain_dbstore.go`):
```go
func PrincipalFromDB(p dbstore.Principal) *domain.Principal {
    return &domain.Principal{
        ID:        p.ID,
        Name:      p.Name,
        Type:      p.Type,
        IsAdmin:   p.IsAdmin != 0,
        CreatedAt: parseTime(p.CreatedAt),
    }
}
```

### IntrospectionRepository is special:
- Queries DuckLake metadata tables (`ducklake_schema`, `ducklake_table`, `ducklake_column`) directly via raw SQL (not sqlc, since those tables aren't in our migrations)
- Uses the same `*sql.DB` SQLite connection

### AuditRepository:
- Uses new sqlc queries from `db/queries/audit.sql`
- `List()` supports filtering by principal, action, status, date range + pagination

### Files:
- Create: `internal/repository/principal.go`, `internal/repository/group.go`, `internal/repository/grant.go`, `internal/repository/row_filter.go`, `internal/repository/column_mask.go`, `internal/repository/audit.go`, `internal/repository/introspection.go`
- Create: `internal/mapper/domain_dbstore.go`

### Verify:
```
go build ./internal/repository/...
```

---

## Phase 5: Service Layer

### Services and their responsibilities:

**`internal/service/query.go` — QueryService**
```go
type QueryService struct {
    engine *engine.SecureEngine
    audit  domain.AuditRepository
}

func (s *QueryService) Execute(ctx context.Context, principalName, sql string) (*QueryResult, error)
```
- Wraps `SecureEngine.Query()`, converts `*sql.Rows` to `QueryResult` (column names + row data as `[][]interface{}`)
- Writes audit entry on every query (success or failure)
- Returns structured result suitable for JSON serialization

**`internal/service/principal.go` — PrincipalService**
- CRUD operations on principals
- Validates uniqueness, type constraints
- Writes audit entries for create/delete/admin changes

**`internal/service/group.go` — GroupService**
- CRUD for groups + member management
- Validates member existence before adding
- Prevents circular group membership

**`internal/service/grant.go` — GrantService**
- Grant/revoke privileges
- Validates securable exists (queries introspection repo for table/schema IDs)
- Validates privilege names against known set

**`internal/service/row_filter.go` — RowFilterService**
- CRUD for row filters (now multiple per table)
- Bind/unbind filters to principals/groups
- Validates filter SQL by attempting parse via `sqlrewrite.InjectRowFilterSQL` (dry-run)

**`internal/service/column_mask.go` — ColumnMaskService**
- CRUD for column masks
- Bind/unbind with see_original flag
- Validates mask expression syntax

**`internal/service/introspection.go` — IntrospectionService**
- List schemas, tables, columns from DuckLake metadata
- For each table: include the principal's effective permissions, active row filters, column masks
- This is the "what can I see?" endpoint

**`internal/service/audit.go` — AuditService**
- Query audit logs with filters and pagination
- Read-only (only AuditRepository.Insert is called from other services)

### Files:
- Create: `internal/service/query.go`, `internal/service/principal.go`, `internal/service/group.go`, `internal/service/grant.go`, `internal/service/row_filter.go`, `internal/service/column_mask.go`, `internal/service/introspection.go`, `internal/service/audit.go`

### Verify:
```
go build ./internal/service/...
```

---

## Phase 6: Update Engine for Multiple Row Filters

### Changes to `catalog/service.go`:
- `GetEffectiveRowFilter` → `GetEffectiveRowFilters` (returns `[]string` instead of `*string`)
- Collects ALL matching row filters for the principal (direct + via groups)
- Multiple filters are combined with `OR` (each filter represents a separate visibility window)

### Changes to `engine/engine.go`:
- Loop over `[]string` filters, inject each with `InjectRowFilterSQL`
- When multiple filters exist for the same table, combine them: `(filter1) OR (filter2)`

### Changes to `sqlrewrite/sqlrewrite.go`:
- Add `InjectMultipleRowFilters(sql, tableName string, filters []string) (string, error)` that wraps individual filters in parens and ORs them together before injection

### Files:
- Modify: `catalog/service.go`, `engine/engine.go`, `sqlrewrite/sqlrewrite.go`
- Modify: `catalog/service_test.go`, `engine/engine_test.go`, `sqlrewrite/sqlrewrite_test.go`

### Verify:
```
go test -race ./catalog/... ./engine/... ./sqlrewrite/...
```

---

## Phase 7: OpenAPI Spec + Code Generation

### `api/openapi.yaml` — Complete OpenAPI 3.0 Spec

**Security schemes:**
```yaml
securitySchemes:
  BearerAuth:
    type: http
    scheme: bearer
    bearerFormat: JWT
  ApiKeyAuth:
    type: apiKey
    in: header
    name: X-API-Key
security:
  - BearerAuth: []
  - ApiKeyAuth: []
```

**Endpoint groups:**

| Method | Path | Operation | Description |
|--------|------|-----------|-------------|
| POST | `/v1/query` | executeQuery | Execute SQL as authenticated principal |
| GET | `/v1/principals` | listPrincipals | List all principals |
| POST | `/v1/principals` | createPrincipal | Create a principal |
| GET | `/v1/principals/{id}` | getPrincipal | Get principal by ID |
| DELETE | `/v1/principals/{id}` | deletePrincipal | Delete a principal |
| PUT | `/v1/principals/{id}/admin` | setAdmin | Set/unset admin flag |
| GET | `/v1/groups` | listGroups | List all groups |
| POST | `/v1/groups` | createGroup | Create a group |
| GET | `/v1/groups/{id}` | getGroup | Get group by ID |
| DELETE | `/v1/groups/{id}` | deleteGroup | Delete a group |
| GET | `/v1/groups/{id}/members` | listGroupMembers | List group members |
| POST | `/v1/groups/{id}/members` | addGroupMember | Add member to group |
| DELETE | `/v1/groups/{id}/members` | removeGroupMember | Remove member from group |
| GET | `/v1/grants` | listGrants | List grants (filtered) |
| POST | `/v1/grants` | grantPrivilege | Grant a privilege |
| DELETE | `/v1/grants` | revokePrivilege | Revoke a privilege |
| GET | `/v1/tables/{tableId}/row-filters` | listRowFilters | List row filters for table |
| POST | `/v1/tables/{tableId}/row-filters` | createRowFilter | Create row filter |
| DELETE | `/v1/row-filters/{id}` | deleteRowFilter | Delete row filter |
| POST | `/v1/row-filters/{id}/bindings` | bindRowFilter | Bind filter to principal |
| DELETE | `/v1/row-filters/{id}/bindings` | unbindRowFilter | Unbind filter |
| GET | `/v1/tables/{tableId}/column-masks` | listColumnMasks | List column masks |
| POST | `/v1/tables/{tableId}/column-masks` | createColumnMask | Create column mask |
| DELETE | `/v1/column-masks/{id}` | deleteColumnMask | Delete column mask |
| POST | `/v1/column-masks/{id}/bindings` | bindColumnMask | Bind mask to principal |
| DELETE | `/v1/column-masks/{id}/bindings` | unbindColumnMask | Unbind mask |
| GET | `/v1/schemas` | listSchemas | List DuckLake schemas |
| GET | `/v1/schemas/{id}/tables` | listTables | List tables in schema |
| GET | `/v1/tables/{id}/columns` | listColumns | List columns in table |
| GET | `/v1/audit-logs` | listAuditLogs | Query audit logs |

**Common response schemas:**
```yaml
Error:
  type: object
  required: [code, message]
  properties:
    code: { type: integer }
    message: { type: string }

QueryResult:
  type: object
  properties:
    columns: { type: array, items: { type: string } }
    rows: { type: array, items: { type: array, items: {} } }
    row_count: { type: integer }

PaginatedResponse:
  # Used for list endpoints
  properties:
    data: { ... }
    total: { type: integer }
    limit: { type: integer }
    offset: { type: integer }
```

### oapi-codegen Configuration

**`api/types.cfg.yaml`:**
```yaml
package: api
output: types.gen.go
generate:
  models: true
```

**`api/server.cfg.yaml`:**
```yaml
package: api
output: server.gen.go
generate:
  chi-server: true
  strict-server: true
  embedded-spec: true
```

### Makefile targets:
```makefile
.PHONY: generate-api
generate-api:
	oapi-codegen --config api/types.cfg.yaml api/openapi.yaml
	oapi-codegen --config api/server.cfg.yaml api/openapi.yaml

.PHONY: generate
generate: generate-api sqlc
```

### Files:
- Create: `api/openapi.yaml`, `api/types.cfg.yaml`, `api/server.cfg.yaml`
- Generate: `api/types.gen.go`, `api/server.gen.go`
- Modify: `Makefile`
- Modify: `go.mod` (add `github.com/oapi-codegen/oapi-codegen/v2`, `github.com/go-chi/chi/v5`, runtime deps)

### Verify:
```
make generate-api
go build ./api/...
```

---

## Phase 8: Auth Middleware + Handler Implementation

### `internal/middleware/auth.go`

```go
// contextKey for principal name
type principalKey struct{}

func WithPrincipal(ctx context.Context, name string) context.Context
func PrincipalFromContext(ctx context.Context) (string, bool)

// AuthMiddleware tries JWT first, then API key
func AuthMiddleware(jwtSecret []byte, apiKeyRepo domain.APIKeyRepository) func(http.Handler) http.Handler
```

**JWT flow:**
1. Extract `Authorization: Bearer <token>` header
2. Parse and validate JWT with HMAC-SHA256
3. Extract `sub` claim as principal name
4. Store in context via `WithPrincipal()`

**API Key flow:**
1. Extract `X-API-Key` header
2. SHA-256 hash the key
3. Lookup hash in `api_keys` table → get `principal_id`
4. Lookup principal name
5. Store in context

**Error handling:** Return 401 Unauthorized with JSON error body if both methods fail.

### `api/handler.go` — Implements `StrictServerInterface`

The strict server generates an interface like:
```go
type StrictServerInterface interface {
    ExecuteQuery(ctx context.Context, request ExecuteQueryRequestObject) (ExecuteQueryResponseObject, error)
    ListPrincipals(ctx context.Context, request ListPrincipalsRequestObject) (ListPrincipalsResponseObject, error)
    CreatePrincipal(ctx context.Context, request CreatePrincipalRequestObject) (CreatePrincipalResponseObject, error)
    // ... etc
}
```

The handler delegates to services:
```go
type Handler struct {
    query         *service.QueryService
    principals    *service.PrincipalService
    groups        *service.GroupService
    grants        *service.GrantService
    rowFilters    *service.RowFilterService
    columnMasks   *service.ColumnMaskService
    introspection *service.IntrospectionService
    audit         *service.AuditService
}

func (h *Handler) ExecuteQuery(ctx context.Context, req api.ExecuteQueryRequestObject) (api.ExecuteQueryResponseObject, error) {
    principal, _ := middleware.PrincipalFromContext(ctx)
    result, err := h.query.Execute(ctx, principal, req.Body.Sql)
    if err != nil {
        return mapErrorToResponse(err), nil
    }
    return api.ExecuteQuery200JSONResponse{...}, nil
}
```

### Domain error → HTTP status mapping (`internal/mapper/domain_api.go`):
```
domain.NotFoundError    → 404
domain.AccessDeniedError → 403
domain.ValidationError  → 400
domain.ConflictError    → 409
```

### Files:
- Create: `internal/middleware/auth.go`, `internal/middleware/auth_test.go`
- Create: `api/handler.go`
- Create: `internal/mapper/domain_api.go`
- Modify: `go.mod` (add `github.com/golang-jwt/jwt/v5`)

### Verify:
```
go build ./api/... ./internal/...
```

---

## Phase 9: Wire Everything in main.go

### Updated `main.go` flow:
```go
func main() {
    // 1. Load config (extended with JWT_SECRET, LISTEN_ADDR)
    cfg := config.LoadFromEnv()

    // 2. Open DuckDB + SQLite
    duckDB, _ := sql.Open("duckdb", "")
    metaDB, _ := sql.Open("sqlite3", cfg.MetaDBPath+"?_foreign_keys=on")

    // 3. Run migrations
    catalog.RunMigrations(metaDB)

    // 4. Setup DuckLake (optional, with S3)
    engine.SetupDuckLake(ctx, duckDB, cfg)

    // 5. Create repositories
    principalRepo := repository.NewPrincipalRepo(metaDB)
    groupRepo := repository.NewGroupRepo(metaDB)
    // ... etc

    // 6. Create services
    catalogSvc := catalog.NewCatalogService(metaDB)
    eng := engine.NewSecureEngine(duckDB, catalogSvc)
    querySvc := service.NewQueryService(eng, auditRepo)
    principalSvc := service.NewPrincipalService(principalRepo, auditRepo)
    // ... etc

    // 7. Create handler
    handler := api.NewHandler(querySvc, principalSvc, groupSvc, ...)

    // 8. Create strict handler wrapper
    strictHandler := api.NewStrictHandler(handler, nil)

    // 9. Setup Chi router
    r := chi.NewRouter()
    r.Use(middleware.Logger)
    r.Use(middleware.Recoverer)
    r.Use(authMiddleware.AuthMiddleware(cfg.JWTSecret, apiKeyRepo))

    // 10. Register routes
    api.HandlerFromMux(strictHandler, r)

    // 11. Start server
    log.Printf("listening on %s", cfg.ListenAddr)
    http.ListenAndServe(cfg.ListenAddr, r)
}
```

### Config additions:
```go
// New fields in config.Config:
JWTSecret  string // JWT_SECRET env var (required for API mode)
ListenAddr string // LISTEN_ADDR env var, default ":8080"
```

### Files:
- Modify: `main.go` (complete rewrite of entry point)
- Modify: `config/config.go` (add JWTSecret, ListenAddr fields)
- Modify: `config/config_test.go`

### Verify:
```
go build ./...
go run main.go  # should start HTTP server on :8080
```

---

## Phase 10: DML Protection + Integration Tests

### DML through DuckLake:
- INSERT/UPDATE/DELETE are already privilege-checked in `engine.Query()` via `privilegeForStatement()`
- Test these with real DuckDB + DuckLake to ensure they work end-to-end
- Add engine tests: `TestInsertRequiresPrivilege`, `TestUpdateRequiresPrivilege`, `TestDeleteRequiresPrivilege`
- Test that granted INSERT/UPDATE/DELETE principals can actually execute DML

### API integration tests (`api/handler_test.go`):
```go
func setupTestServer(t *testing.T) (*httptest.Server, *Handler) {
    // 1. Create in-memory SQLite + run migrations
    // 2. Create in-memory DuckDB + load titanic.parquet
    // 3. Create all repos, services, handler
    // 4. Wire Chi router with test auth (fixed principal)
    // 5. Return httptest.Server
}
```

Test scenarios:
- Query execution as different principals (admin, analyst, no_access)
- CRUD lifecycle for principals, groups, grants
- Row filter creation + binding + query enforcement
- Column mask creation + binding + query enforcement
- Audit log entries appear after operations
- 401 for missing auth, 403 for insufficient privileges
- Schema introspection returns correct tables/columns

### Files:
- Create: `api/handler_test.go`
- Modify: `engine/engine_test.go` (add DML tests)

### Verify:
```
go test -race ./...
```

---

## Implementation Order Summary

| Phase | Description | Dependencies | Key Files |
|-------|-------------|--------------|-----------|
| 1 | Remove policy/ | None | `sqlrewrite/`, delete `policy/` |
| 2 | New migrations (006-008) | None | `db/migrations/`, `db/queries/`, `catalog/migrations/` |
| 3 | Domain layer | None | `domain/*.go` |
| 4 | Repository implementations | Phase 2, 3 | `internal/repository/*.go`, `internal/mapper/domain_dbstore.go` |
| 5 | Service layer | Phase 4 | `internal/service/*.go` |
| 6 | Multiple row filters | Phase 2 | `catalog/service.go`, `engine/engine.go`, `sqlrewrite/sqlrewrite.go` |
| 7 | OpenAPI spec + codegen | None | `api/openapi.yaml`, `api/*.gen.go` |
| 8 | Auth middleware + handlers | Phase 5, 7 | `internal/middleware/auth.go`, `api/handler.go` |
| 9 | Wire main.go | Phase 8 | `main.go`, `config/config.go` |
| 10 | DML protection + tests | Phase 9 | `engine/engine_test.go`, `api/handler_test.go` |

Phases 1, 2, 3, 7 can be done in parallel (no dependencies between them).
Phases 4+5 and 6 can be done in parallel once their prerequisites are met.

---

## New Dependencies

| Package | Purpose |
|---------|---------|
| `github.com/oapi-codegen/oapi-codegen/v2` | Code generation (dev tool) |
| `github.com/oapi-codegen/runtime` | Runtime helpers for generated code |
| `github.com/go-chi/chi/v5` | HTTP router |
| `github.com/golang-jwt/jwt/v5` | JWT parsing/validation |
| `github.com/getkin/kin-openapi` | OpenAPI spec validation (transitive via oapi-codegen runtime) |

---

## Verification Checklist

1. `make generate` — regenerates all code (sqlc + oapi-codegen)
2. `go build ./...` — clean compile
3. `go vet ./...` — no issues
4. `go test -race ./...` — all tests pass
5. `go run main.go` — starts HTTP server
6. Manual smoke test:
   ```bash
   # Get a JWT (or use API key)
   # Execute query
   curl -H "Authorization: Bearer $TOKEN" \
        -d '{"sql": "SELECT * FROM titanic LIMIT 5"}' \
        http://localhost:8080/v1/query

   # List principals
   curl -H "X-API-Key: $KEY" http://localhost:8080/v1/principals

   # Introspect schemas
   curl -H "X-API-Key: $KEY" http://localhost:8080/v1/schemas
   ```
7. Verify audit entries: `curl http://localhost:8080/v1/audit-logs`
8. Verify DML protection: POST INSERT/UPDATE/DELETE queries and confirm privilege enforcement
