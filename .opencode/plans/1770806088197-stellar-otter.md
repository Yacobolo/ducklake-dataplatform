# Plan: Runtime External Locations (Remove Hardcoded Data Lake Config)

## Goal
Make the app start without any S3 configuration. External storage locations and credentials are managed at runtime via API. DuckLake catalog attaches dynamically when the first location is registered.

## Design Decisions
1. **Start without S3** — app boots with DuckDB + SQLite only; no `.env` S3 vars required
2. **First-class CRUD resources** — Storage Credentials and External Locations modeled as Unity Catalog-style resources
3. **Single `lake` catalog, multiple paths** — DuckLake schema-level `path` for multi-bucket support
4. **Credentials stored encrypted** — AES-256-GCM in SQLite, decrypted in memory
5. **DuckDB secrets created at runtime** — `CREATE SECRET` when locations are registered
6. **Backward compatible** — legacy `.env` S3 config still works if present

---

## Phase 1: Make S3 Optional at Startup

### `internal/config/config.go`
- Make S3 fields `*string` (pointer = optional)
- Remove `ParquetPath` field
- Add `EncryptionKey string` (hex-encoded 32-byte AES key, env var `ENCRYPTION_KEY`)
- `LoadFromEnv()` never errors — returns defaults for everything
- Add `HasS3Config() bool` method

### `internal/config/config_test.go`
- Update existing tests for pointer-based S3 fields
- Remove tests that expect errors on missing S3 vars
- Add `TestLoadFromEnv_NoS3`, `TestLoadFromEnv_WithS3`, `TestHasS3Config`

### `internal/engine/engine.go`
Split `SetupDuckLake()` into composable functions:
- `InstallExtensions(ctx, db)` — INSTALL/LOAD ducklake, sqlite, httpfs
- `CreateS3Secret(ctx, db, name, keyID, secret, endpoint, region, urlStyle)` — parameterized secret creation
- `DropS3Secret(ctx, db, name)` — DROP SECRET IF EXISTS
- `AttachDuckLake(ctx, db, metaDBPath, dataPath)` — ATTACH + USE lake
- `IsCatalogAttached(ctx, db) bool` — checks if lake catalog exists
- Keep deprecated `SetupDuckLake()` wrapper for existing tests

### `cmd/server/main.go`
- Open DuckDB → `InstallExtensions()` (always)
- If `cfg.HasS3Config()`: create legacy secret + attach DuckLake (backward compat)
- Else: log "No S3 config — use External Locations API"
- Remove `seedCatalog()` / titanic.parquet logic
- Guard `manifestSvc` and `ingestionSvc` creation behind catalog-attached check

**Verify:** `task build && task test` passes. App starts with empty `.env`.

---

## Phase 2: Domain Model

### `internal/domain/external_location.go` (new)
Types:
- `StorageType` (string enum: `S3`)
- `CredentialType` (string enum: `S3`)
- `StorageCredential` — ID, Name, CredentialType, KeyID, Secret, Endpoint, Region, URLStyle, Comment, Owner, CreatedAt, UpdatedAt
- `ExternalLocation` — ID, Name, URL, CredentialName, StorageType, Comment, Owner, ReadOnly, CreatedAt, UpdatedAt
- `Create*Request`, `Update*Request` structs
- `Validate*Request()` functions

### `internal/domain/repository.go` (append)
```go
type StorageCredentialRepository interface {
    Create, GetByID, GetByName, List, Update, Delete
}
type ExternalLocationRepository interface {
    Create, GetByID, GetByName, List, Update, Delete
}
```

### `internal/domain/external_location_test.go` (new)
- Table-driven validation tests for both request types

**Verify:** `task test` — domain validation tests pass.

---

## Phase 3: Database Layer

### Migrations
- `019_create_storage_credentials.sql` — id, name (UNIQUE), credential_type, key_id_encrypted, secret_encrypted, endpoint, region, url_style, comment, owner, timestamps
- `020_create_external_locations.sql` — id, name (UNIQUE), url, credential_name (FK→storage_credentials.name), storage_type, comment, owner, read_only, timestamps

### sqlc Queries
- `internal/db/queries/storage_credentials.sql` — Create, Get, GetByName, List, Count, Update, Delete
- `internal/db/queries/external_locations.sql` — Create, Get, GetByName, List, Count, Update, Delete

### `internal/db/crypto/encrypt.go` (new package)
- `Encryptor` struct wrapping `cipher.AEAD` (AES-256-GCM)
- `NewEncryptor(hexKey)`, `Encrypt(plaintext) → hex`, `Decrypt(hex) → plaintext`
- Tests: round-trip, invalid key, different lengths

### Repositories
- `internal/db/repository/storage_credential.go` — encrypts KeyID/Secret on write, decrypts on read
- `internal/db/repository/external_location.go` — standard CRUD, uses mapper
- Both: compile-time interface checks, `mapDBError()` for SQLite constraint mapping

### Mapper
- `internal/db/mapper/` — `ExternalLocationFromDB()` function

**Verify:** `task sqlc && task build && task test` — repo tests with real SQLite pass.

---

## Phase 4: Service Layer

### `internal/service/storage_credential.go` (new)
- RBAC: requires `ALL_PRIVILEGES` on catalog for create/delete
- Delegates to repository
- Audit logging (best-effort)

### `internal/service/external_location.go` (new)
- `ExternalLocationService` holds: repos, auth, audit, duckDB, metaPath, mu+catalogAttached
- `Create()`: validate → persist to SQLite → `engine.CreateS3Secret()` → `AttachDuckLake()` if first location
- `Delete()`: RBAC → `engine.DropS3Secret()` → delete from SQLite
- `RestoreSecrets(ctx)`: on startup, recreate DuckDB secrets for all persisted locations + attach catalog
- `SetCatalogAttached(bool)`: for legacy S3 mode to mark catalog as already attached
- Rollback on DuckDB secret creation failure (delete from SQLite)

### Mocks
- `internal/service/mock_test.go` — add `mockStorageCredentialRepo`, `mockExternalLocationRepo`

**Verify:** `task build && task test` — service tests with mocks pass.

---

## Phase 5: API Layer

### `internal/api/openapi.yaml`
New schemas: `StorageCredential`, `CreateStorageCredentialRequest`, `PaginatedStorageCredentials`, `ExternalLocation`, `CreateExternalLocationRequest`, `PaginatedExternalLocations`

New paths:
- `GET/POST /storage-credentials` — list/create
- `GET/DELETE /storage-credentials/{credential_name}` — get/delete
- `GET/POST /external-locations` — list/create
- `GET/DELETE /external-locations/{location_name}` — get/delete

**Important:** `StorageCredential` response schema does NOT include `key_id` or `secret` (never expose credentials in API responses).

### Run `task generate-api`

### `internal/api/handler.go`
- Add `storageCreds`, `externalLocations` fields to `APIHandler`
- Implement 8 handler methods (following existing pattern: domain error type-switch)
- Add `storageCredentialToAPI()`, `externalLocationToAPI()` mapping helpers
- Update `NewHandler()` signature

### `cmd/server/main.go`
- Create `Encryptor` from `cfg.EncryptionKey`
- Create repos: `NewStorageCredentialRepo(writeDB, enc)`, `NewExternalLocationRepo(writeDB)`
- Create services: `NewStorageCredentialService(...)`, `NewExternalLocationService(..., duckDB, cfg.MetaDBPath)`
- If `cfg.HasS3Config()`: `extLocationSvc.SetCatalogAttached(true)`
- Call `extLocationSvc.RestoreSecrets(ctx)` on startup
- Pass new services to `NewHandler()`

**Verify:** `task generate-api && task build && task test` — full API wired.

---

## Phase 6: Wire Locations into Schema Creation

### `internal/domain/catalog.go`
Add `LocationName string` to `CreateSchemaRequest`

### `internal/domain/repository.go`
Add `SetSchemaStoragePath(ctx, schemaID int64, path string) error` to `CatalogRepository`

### `internal/db/repository/catalog.go`
```go
func (r *CatalogRepo) SetSchemaStoragePath(ctx, schemaID, path) error {
    UPDATE ducklake_schema SET path = ?, path_is_relative = 0 WHERE schema_id = ?
}
```

### `internal/service/catalog.go`
- After `CreateSchema`, if `req.LocationName != ""`: look up location, set schema path
- Needs `ExternalLocationRepository` dependency added to `CatalogService`

### `internal/api/openapi.yaml`
Add optional `location_name` field to `CreateSchemaRequest`

### Run `task generate-api`

### `internal/api/handler.go`
Pass `req.Body.LocationName` through to domain request

**Verify:** `task generate-api && task build && task test`

---

## Phase 7: Update Existing Consumers

### `internal/service/presigner.go`
Add `NewS3PresignerFromCredential(cred *domain.StorageCredential) (*S3Presigner, error)` — creates presigner from stored credential

### `internal/service/ingestion.go`
- Add `credRepo` dependency to resolve credentials per-schema
- Resolve bucket/path from schema's location rather than hardcoded `cfg.S3Bucket`
- Keep backward compat when legacy S3 mode is active

### `internal/service/manifest.go`
- Replace single `S3Presigner` with credential-aware presigner factory
- `resolveDataFiles()` uses schema-level `data_path` when available

**Verify:** `task build && task test && task integration-test` (integration needs S3 creds)

---

## Files Summary

### New Files (15)
| File | Phase |
|------|-------|
| `internal/domain/external_location.go` | 2 |
| `internal/domain/external_location_test.go` | 2 |
| `internal/db/migrations/019_create_storage_credentials.sql` | 3 |
| `internal/db/migrations/020_create_external_locations.sql` | 3 |
| `internal/db/queries/storage_credentials.sql` | 3 |
| `internal/db/queries/external_locations.sql` | 3 |
| `internal/db/crypto/encrypt.go` | 3 |
| `internal/db/crypto/encrypt_test.go` | 3 |
| `internal/db/repository/storage_credential.go` | 3 |
| `internal/db/repository/external_location.go` | 3 |
| `internal/db/repository/storage_credential_test.go` | 3 |
| `internal/db/repository/external_location_test.go` | 3 |
| `internal/service/storage_credential.go` | 4 |
| `internal/service/external_location.go` | 4 |
| `internal/service/external_location_test.go` | 4 |

### Modified Files (15)
| File | Phase |
|------|-------|
| `internal/config/config.go` | 1 |
| `internal/config/config_test.go` | 1 |
| `internal/engine/engine.go` | 1 |
| `cmd/server/main.go` | 1, 5 |
| `internal/domain/repository.go` | 2 |
| `internal/domain/catalog.go` | 6 |
| `internal/db/mapper/domain_dbstore.go` (or similar) | 3 |
| `internal/api/openapi.yaml` | 5, 6 |
| `internal/api/handler.go` | 5 |
| `internal/service/catalog.go` | 6 |
| `internal/db/repository/catalog.go` | 6 |
| `internal/service/presigner.go` | 7 |
| `internal/service/ingestion.go` | 7 |
| `internal/service/manifest.go` | 7 |
| `test/integration/helpers_test.go` | 8 |

### New Test Files (2)
| File | Phase |
|------|-------|
| `test/integration/storage_credentials_http_test.go` | 8 |
| `test/integration/external_locations_http_test.go` | 8 |

### Regenerated Files
| File | Trigger |
|------|---------|
| `internal/api/types.gen.go` | `task generate-api` |
| `internal/api/server.gen.go` | `task generate-api` |
| `internal/db/dbstore/*.sql.go` | `task sqlc` |
| `internal/db/dbstore/models.go` | `task sqlc` |

---

## Phase 8: Integration Tests for Storage Credentials & External Locations

### `test/integration/helpers_test.go` (edit)

Add to `httpTestOpts`:
```go
WithStorageCredentials bool // wires StorageCredentialService + ExternalLocationService
```

Add to `httpTestEnv`:
```go
ExtLocationSvc *service.ExternalLocationService // for calling SetCatalogAttached in tests
```

In `setupHTTPServer`, when `opts.WithStorageCredentials` is true:
1. Create `crypto.Encryptor` with test key `"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"`
2. Create `StorageCredentialRepo(metaDB, enc)` and `ExternalLocationRepo(metaDB)`
3. Create `StorageCredentialService` and `ExternalLocationService`
4. If `duckDB` is nil, open a plain in-memory DuckDB for `ExternalLocationService` (needs it for `CREATE SECRET` / `DROP SECRET`)
5. Pass both services to `NewHandler` instead of `nil, nil`
6. Set `httpTestEnv.ExtLocationSvc = extLocationSvc`

New import: `"duck-demo/internal/db/crypto"`

### `test/integration/storage_credentials_http_test.go` (new)

All tests use `setupHTTPServer(t, httpTestOpts{WithStorageCredentials: true})`.

**`TestHTTP_StorageCredentialCRUD`** — sequential subtests (shared state):
- `create` — POST valid credential → 201, verify returned fields
- `create_omits_secrets` — verify response has NO `key_id` or `secret` keys
- `get_by_name` — GET → 200, verify fields match
- `get_omits_secrets` — verify GET response also omits secrets
- `list_returns_created` — GET list, verify our credential is present
- `list_omits_secrets` — verify list items omit secrets
- `update_comment` — PATCH comment → 200, verify updated
- `update_endpoint_and_region` — PATCH both fields, verify
- `update_preserves_unset_fields` — PATCH only comment, verify other fields unchanged
- `delete` — DELETE → 204
- `get_after_delete_404` — GET → 404

**`TestHTTP_StorageCredentialAuthorization`** — table-driven:
- `admin_create_201` / `analyst_create_403` / `noaccess_create_403`
- `analyst_update_403` / `analyst_delete_403`
- `analyst_list_200` / `analyst_get_200` / `noaccess_list_200` / `noaccess_get_200`

**`TestHTTP_StorageCredentialValidation`** — table-driven:
- `empty_name_400` / `name_too_long_400` / `invalid_credential_type_400`
- `missing_key_id_400` / `missing_secret_400` / `missing_endpoint_400` / `missing_region_400`
- `get_nonexistent_404` / `update_nonexistent_404` / `delete_nonexistent_404`

**`TestHTTP_StorageCredentialDuplicate`** — create same name twice → 409

**`TestHTTP_StorageCredentialPagination`** — create 5 credentials, paginate with `max_results=2`, verify all collected in sorted order

### `test/integration/external_locations_http_test.go` (new)

All tests use `setupHTTPServer(t, httpTestOpts{WithStorageCredentials: true})`.
Tests that create locations call `env.ExtLocationSvc.SetCatalogAttached(true)` to skip the `AttachDuckLake` step (no real S3 bucket). `CreateS3Secret` still runs on the in-memory DuckDB.

**`TestHTTP_ExternalLocationCRUD`** — sequential subtests:
- `setup_credential` — create a prerequisite storage credential
- `create_location` — POST valid location → 201, verify fields
- `get_by_name` — GET → 200, verify fields
- `list_returns_created` — GET list, verify present
- `update_comment` — PATCH comment → 200
- `update_url` — PATCH url → 200
- `update_read_only` — PATCH read_only → 200
- `delete` — DELETE → 204
- `get_after_delete_404` — GET → 404

**`TestHTTP_ExternalLocationAuthorization`** — table-driven:
- `admin_create_201` / `analyst_create_403` / `noaccess_create_403`
- `analyst_update_403` / `analyst_delete_403`
- `analyst_list_200` / `analyst_get_200` / `noaccess_list_200`

**`TestHTTP_ExternalLocationValidation`** — table-driven:
- `empty_name_400` / `name_too_long_400` / `missing_url_400`
- `missing_credential_name_400` / `invalid_storage_type_400`
- `nonexistent_credential_error` — credential_name references a non-existent credential
- `get_nonexistent_404` / `update_nonexistent_404` / `delete_nonexistent_404`

**`TestHTTP_ExternalLocationDuplicate`** — create same name twice → 409

**`TestHTTP_ExternalLocationPagination`** — create 5 locations (with 5 credentials), paginate with `max_results=2`

### Key Design Decisions

1. **No S3 dependency**: All tests run against in-memory DuckDB + temp SQLite. `CREATE SECRET` succeeds on plain DuckDB. `AttachDuckLake` is skipped via `SetCatalogAttached(true)`.
2. **Secret omission**: Explicitly assert `key_id` and `secret` keys are absent from JSON responses (not just nil/zero — the keys themselves must not exist).
3. **Auth checks happen before validation**: Authorization tests use valid-looking bodies so the 403 is definitively from RBAC, not from a pre-auth validation failure.
4. **Implicit encryption round-trip**: The Create→Get flow implicitly validates that encrypt/decrypt works correctly in the repo layer.

**Verify:** `task integration-test` — all new tests pass without S3 credentials.

---

## Verification
After each phase: `task build && task test`
After Phase 5: `task generate-api && task build && task test`
After Phase 8: `task integration-test` — new storage credential & external location tests pass
End-to-end: Start server with no `.env` S3 → POST /storage-credentials → POST /external-locations → POST /catalog/schemas (with location_name) → verify DuckLake attached and schema path set
