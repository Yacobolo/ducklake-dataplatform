# Plan: Missing Integration Tests & Bug Fixes

## Summary

5 confirmed security bugs + 12 new tests across engine, SQL rewrite, and HTTP layers.

---

## Phase 1: FIX-1 — Multi-statement SQL injection (CRITICAL)

**Bug:** `ClassifyStatement` only checks `result.Stmts[0]`. `SELECT 1; DROP TABLE titanic` classifies as SELECT, extracts no tables (DROP not handled by `collectTablesFromNode`), hits `len(tables)==0` path at `engine.go:69`, and executes the full multi-statement string unguarded.

**File:** `internal/sqlrewrite/sqlrewrite.go`

**Change:** In `ClassifyStatement` (line 116), after the `len(result.Stmts) == 0` check, add:
```go
if len(result.Stmts) > 1 {
    return StmtOther, fmt.Errorf("multi-statement queries are not allowed")
}
```

**Test:** Add to `internal/sqlrewrite/sqlrewrite_test.go`:
```go
func TestClassifyStatement_MultiStatementRejected(t *testing.T) {
    tests := []struct {
        name string
        sql  string
    }{
        {"select_then_drop", "SELECT 1; DROP TABLE titanic"},
        {"select_then_insert", "SELECT 1; INSERT INTO titanic VALUES (1)"},
        {"two_selects", "SELECT 1; SELECT 2"},
    }
    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            _, err := ClassifyStatement(tc.sql)
            if err == nil {
                t.Error("expected error for multi-statement SQL")
            }
        })
    }
}
```

**Also add engine-level test** to `internal/engine/engine_test.go`:
```go
func TestMultiStatementBlocked(t *testing.T) {
    eng := setupEngine(t)
    _, err := eng.Query(context.Background(), "admin", "SELECT 1; DROP TABLE titanic")
    if err == nil {
        t.Error("expected multi-statement query to be blocked")
    }
}
```

---

## Phase 2: FIX-2 — Table-less statement bypass (CRITICAL)

**Bug:** `engine.go:69-76` — when `ExtractTableNames` returns empty, query executes with zero auth. Allows `SELECT read_parquet('s3://...')` etc.

**File:** `internal/engine/engine.go`

**Change:** Replace lines 69-76:
```go
if len(tables) == 0 {
    // Table-less queries require catalog-level SELECT (admin bypass already checked upstream)
    allowed, authErr := e.catalog.CheckPrivilege(ctx, principalName, domain.SecurableCatalog, domain.CatalogID, requiredPriv)
    if authErr != nil {
        return nil, fmt.Errorf("privilege check: %w", authErr)
    }
    if !allowed {
        return nil, fmt.Errorf("access denied: %q lacks %s privilege for table-less queries", principalName, requiredPriv)
    }
    rows, err := e.db.QueryContext(ctx, sqlQuery)
    if err != nil {
        return nil, fmt.Errorf("execute query: %w", err)
    }
    return rows, nil
}
```

**Test:** Add to `internal/engine/engine_test.go`:
```go
func TestTablelessStatementRequiresAuth(t *testing.T) {
    eng := setupEngine(t)
    ctx := context.Background()

    // Admin should be allowed (has ALL_PRIVILEGES on catalog)
    rows, err := eng.Query(ctx, "admin", "SELECT 1 + 1")
    require.NoError(t, err)
    rows.Close()

    // Non-privileged user should be denied
    _, err = eng.Query(ctx, "first_class_analyst", "SELECT 1 + 1")
    require.Error(t, err)
    assert.Contains(t, err.Error(), "access denied")
}
```

Note: `first_class_analyst` has SELECT on table but NOT on catalog, so this should fail. Admin has ALL_PRIVILEGES on catalog, so admin bypass applies.

---

## Phase 3: FIX-3 — Silent mask parse failure (HIGH)

**Bug:** `sqlrewrite.go:340-341` — `pg_query.Parse` failure on mask expression → `continue` → column exposed unmasked.

**File:** `internal/sqlrewrite/sqlrewrite.go`

**Change:** Make `applyMasksToSelectStmt` return `error`. When parse fails at line 340, return error instead of `continue`:
```go
func applyMasksToSelectStmt(sel *pg_query.SelectStmt, tableName string, masks map[string]string) error {
    // ... existing code ...
    // At line 340:
    maskResult, err := pg_query.Parse("SELECT " + maskExpr + " AS " + QuoteIdentifier(colName))
    if err != nil {
        return fmt.Errorf("parse mask expression for column %q: %w", colName, err)
    }
    // ...
    return nil
}
```

Update `ApplyColumnMasks` to propagate the error from `applyMasksToSelectStmt`.

**Test:** Add to `internal/sqlrewrite/sqlrewrite_test.go`:
```go
func TestApplyColumnMasks_MalformedExpressionErrors(t *testing.T) {
    _, err := ApplyColumnMasks(
        `SELECT "Name" FROM titanic`,
        "titanic",
        map[string]string{"Name": "INVALID SQL $$"},
    )
    if err == nil {
        t.Error("expected error for malformed mask expression")
    }
}

func TestApplyColumnMasks_ValidExpressionSucceeds(t *testing.T) {
    result, err := ApplyColumnMasks(
        `SELECT "Name" FROM titanic`,
        "titanic",
        map[string]string{"Name": "'***'"},
    )
    require.NoError(t, err)
    assert.Contains(t, result, "'***'")
}
```

---

## Phase 4: FIX-4 — information_schema temp table race (HIGH)

**Bug:** `information_schema.go:137` — deterministic temp table name `__info_schema_tables` shared by concurrent queries.

**File:** `internal/engine/information_schema.go`

**Change:** In `queryVirtualTable`, generate unique temp table name:
```go
import "crypto/rand"

func randomSuffix() string {
    b := make([]byte, 4)
    rand.Read(b)
    return fmt.Sprintf("%x", b)
}

// In queryVirtualTable:
tempName := fmt.Sprintf("__info_schema_%s_%s", table, randomSuffix())
```

Also add deferred cleanup after creating the temp table:
```go
// After createSQL exec succeeds:
defer func() {
    _, _ = db.ExecContext(ctx, fmt.Sprintf("DROP TABLE IF EXISTS %s", tempName))
}()
```

**Test:** Add to `internal/engine/information_schema_test.go`:
```go
func TestInformationSchema_ConcurrentQueries(t *testing.T) {
    // This test verifies that concurrent information_schema queries
    // don't corrupt each other's results due to shared temp table names.
    // Uses the mock catalog + a real DuckDB connection.
    // Launch 10 goroutines querying information_schema.tables concurrently.
    // All should return correct results without errors.
}
```

This test needs a real DuckDB connection + mock catalog. Follow the pattern from `engine_test.go` but with `InformationSchemaProvider`.

---

## Phase 5: FIX-5 — Column masking doesn't recurse into subqueries/CTEs (HIGH)

**Bug:** `sqlrewrite.go:280-291` — `ApplyColumnMasks` only processes top-level SELECT + UNION. No recursion into FROM subqueries, WHERE subqueries, or CTEs.

**File:** `internal/sqlrewrite/sqlrewrite.go`

**Change:** In `applyMasksToSelectStmt`, add recursion (mirror `injectFiltersIntoSelectStmt` pattern):
```go
// After UNION recursion (line 300-306), add:

// Recurse into CTEs
if sel.WithClause != nil {
    for _, cte := range sel.WithClause.Ctes {
        if c, ok := cte.Node.(*pg_query.Node_CommonTableExpr); ok {
            if n, ok := c.CommonTableExpr.Ctequery.Node.(*pg_query.Node_SelectStmt); ok {
                if err := applyMasksToSelectStmt(n.SelectStmt, tableName, masks); err != nil {
                    return err
                }
            }
        }
    }
}

// After rewriting target list, recurse into FROM subqueries
for _, from := range sel.FromClause {
    if rs, ok := from.Node.(*pg_query.Node_RangeSubselect); ok {
        if n, ok := rs.RangeSubselect.Subquery.Node.(*pg_query.Node_SelectStmt); ok {
            if err := applyMasksToSelectStmt(n.SelectStmt, tableName, masks); err != nil {
                return err
            }
        }
    }
}
```

**Test:** Add to `internal/sqlrewrite/sqlrewrite_test.go`:
```go
func TestApplyColumnMasks_Subquery(t *testing.T) {
    result, err := ApplyColumnMasks(
        `SELECT "Name" FROM (SELECT "Name" FROM titanic) sub`,
        "titanic",
        map[string]string{"Name": "'***'"},
    )
    require.NoError(t, err)
    assert.Contains(t, result, "'***'")
}

func TestApplyColumnMasks_CTE(t *testing.T) {
    result, err := ApplyColumnMasks(
        `WITH cte AS (SELECT "Name" FROM titanic) SELECT "Name" FROM cte`,
        "titanic",
        map[string]string{"Name": "'***'"},
    )
    require.NoError(t, err)
    assert.Contains(t, result, "'***'")
}
```

---

## Phase 6: GAP Tests (new coverage, no code changes)

All in existing test files. These should pass on current code (after phases 1-5).

### `internal/engine/engine_test.go`:

| Test | Validates |
|------|-----------|
| `TestDDLVariantsBlocked` | Table-driven: CREATE TABLE, ALTER TABLE, TRUNCATE, CREATE SCHEMA all return error |
| `TestMalformedSQLReturnsError` | Garbage SQL `"NOT VALID SQL"` returns parse error |
| `TestMultipleRowFiltersORComposition` | User with 2 row filters sees union (OR) of both |

### `internal/sqlrewrite/sqlrewrite_test.go`:

| Test | Validates |
|------|-----------|
| `TestInjectRowFilterSQL_SelfJoin` | `SELECT * FROM titanic t1 JOIN titanic t2 ON ...` with RLS → filter in both |
| `TestInjectMultipleRowFilters_ORComposition` | Two filters combined with OR in the rewritten SQL |

---

## Phase 7: HTTP Integration Tests

### `test/integration/rbac_workflow_test.go`:

`TestHTTP_ManagementEndpointsNoAuthz` — Documents that analyst can create principals, grant privileges (design gap for future fix):
- `analyst_creates_principal`: POST `/v1/principals` with analyst API key → expect 2xx (documenting gap)
- `analyst_grants_privilege`: POST `/v1/grants` with analyst API key → expect 2xx (documenting gap)

### `test/integration/catalog_http_test.go`:

`TestHTTP_TableProfileAuthorization` — Profile endpoint authz:
- `no_access_denied`: no_access user profiles table → expect 403
- `analyst_allowed`: analyst with SELECT profiles table → expect 200

---

## Files Modified

| File | Changes |
|------|---------|
| `internal/sqlrewrite/sqlrewrite.go` | FIX-1 (multi-stmt reject), FIX-3 (mask error propagation), FIX-5 (mask recursion) |
| `internal/engine/engine.go` | FIX-2 (table-less auth) |
| `internal/engine/information_schema.go` | FIX-4 (unique temp table names) |
| `internal/sqlrewrite/sqlrewrite_test.go` | Tests: multi-stmt, mask errors, subquery/CTE masks, self-join RLS, OR composition |
| `internal/engine/engine_test.go` | Tests: multi-stmt, table-less auth, DDL variants, malformed SQL, multiple row filters |
| `internal/engine/information_schema_test.go` | Test: concurrent info_schema queries |
| `test/integration/rbac_workflow_test.go` | Test: management endpoint authz gap |
| `test/integration/catalog_http_test.go` | Test: profile endpoint authz |

## Verification

```bash
task test    # all unit tests pass (includes engine + sqlrewrite tests)
task vet     # no vet issues
```

## Items Tracked Separately (not in this plan)

1. **Management endpoint authorization** — PrincipalService/GrantService/RowFilterService/ColumnMaskService have zero authz checks (privilege escalation)
2. **SELECT * column masking** — requires column metadata plumbing to expand `*`
3. **information_schema RBAC filtering** — any user sees all schemas/tables
4. **C++ extension manifest cache** — shared across principals, wrong security policies possible
