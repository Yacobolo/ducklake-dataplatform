# Plan: Fix Connection Pool Deadlock in CatalogRepo

## Problem

`TestHTTP_SchemaCRUD/list_contains_created` hangs forever and causes the entire integration test suite to time out after 2 minutes.

### Root Cause

**Connection pool deadlock** in `CatalogRepo.ListSchemas` and `CatalogRepo.ListTables`.

The SQLite `metaDB` write pool is configured with `MaxOpenConns=1` (in `internal/db/sqlite.go`). Both `ListSchemas` and `ListTables` hold an open `*sql.Rows` (which occupies the sole connection) while calling `enrichSchemaMetadata` / `enrichTableMetadata` inside the iteration loop. Those enrich methods call `metaDB.QueryRowContext()` which needs a connection from the same pool — but the only connection is already held by the open `*sql.Rows`. Result: permanent deadlock.

### Why It Only Affects These Two Methods

`ListColumns` (line 471) already follows the correct pattern: it collects all rows first, closes the cursor, then enriches in a separate loop. `ListSchemas` and `ListTables` do not.

## Fix

**File:** `internal/db/repository/catalog.go`

Apply the same "collect then enrich" pattern that `ListColumns` already uses.

### Change 1: `ListSchemas` (lines 162-171)

**Before:**
```go
var schemas []domain.SchemaDetail
for rows.Next() {
    var s domain.SchemaDetail
    if err := rows.Scan(&s.SchemaID, &s.Name); err != nil {
        return nil, 0, err
    }
    s.CatalogName = "lake"
    r.enrichSchemaMetadata(ctx, &s)  // BUG: needs connection while rows holds it
    schemas = append(schemas, s)
}
return schemas, total, rows.Err()
```

**After:**
```go
var schemas []domain.SchemaDetail
for rows.Next() {
    var s domain.SchemaDetail
    if err := rows.Scan(&s.SchemaID, &s.Name); err != nil {
        return nil, 0, err
    }
    s.CatalogName = "lake"
    schemas = append(schemas, s)
}
if err := rows.Err(); err != nil {
    return nil, 0, err
}
for i := range schemas {
    r.enrichSchemaMetadata(ctx, &schemas[i])
}
return schemas, total, nil
```

### Change 2: `ListTables` (lines 402-414)

**Before:**
```go
var tables []domain.TableDetail
for rows.Next() {
    var t domain.TableDetail
    if err := rows.Scan(&t.TableID, &t.Name); err != nil {
        return nil, 0, err
    }
    t.SchemaName = schemaName
    t.CatalogName = "lake"
    t.TableType = "MANAGED"
    r.enrichTableMetadata(ctx, &t)  // BUG: needs connection while rows holds it
    tables = append(tables, t)
}
return tables, total, rows.Err()
```

**After:**
```go
var tables []domain.TableDetail
for rows.Next() {
    var t domain.TableDetail
    if err := rows.Scan(&t.TableID, &t.Name); err != nil {
        return nil, 0, err
    }
    t.SchemaName = schemaName
    t.CatalogName = "lake"
    t.TableType = "MANAGED"
    tables = append(tables, t)
}
if err := rows.Err(); err != nil {
    return nil, 0, err
}
for i := range tables {
    r.enrichTableMetadata(ctx, &tables[i])
}
return tables, total, nil
```

## Files Modified

- `internal/db/repository/catalog.go` — 2 methods changed (`ListSchemas`, `ListTables`)

## Verification

1. `task test` — unit tests pass
2. `task integration-test` — all integration tests pass (no more timeout)
3. Specifically verify `TestHTTP_SchemaCRUD/list_contains_created` completes
