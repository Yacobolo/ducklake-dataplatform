# Plan: Add UC-Compatible Catalog Endpoints + Pagination

## Context

The current API has 31 endpoints focused on RBAC/RLS (principals, groups, grants, row/column security, query execution, manifest). The Unity Catalog reference spec defines 51 operations for full catalog management. The goal is to add catalog management endpoints that **make sense for DuckLake** and add **pagination to all list endpoints**.

## What to Add vs Skip

### ADD (12 new endpoints)

| # | Method | Path | Operation | Rationale |
|---|--------|------|-----------|-----------|
| 1 | GET | `/v1/catalog` | getCatalog | Read-only info about the single `lake` catalog |
| 2 | GET | `/v1/catalog/schemas` | listCatalogSchemas | Paginated schema list (replaces `/v1/schemas`) |
| 3 | POST | `/v1/catalog/schemas` | createSchema | `CREATE SCHEMA lake.{name}` via DuckDB |
| 4 | GET | `/v1/catalog/schemas/{schemaName}` | getSchemaByName | Get schema by name (UC-style) |
| 5 | PATCH | `/v1/catalog/schemas/{schemaName}` | updateSchemaMetadata | Update comment/properties in custom metadata table |
| 6 | DELETE | `/v1/catalog/schemas/{schemaName}` | deleteSchemaCascade | `DROP SCHEMA lake.{name}` via DuckDB |
| 7 | GET | `/v1/catalog/schemas/{schemaName}/tables` | listCatalogTables | Paginated table list by schema name |
| 8 | POST | `/v1/catalog/schemas/{schemaName}/tables` | createTable | `CREATE TABLE lake.{schema}.{name} (...)` via DuckDB |
| 9 | GET | `/v1/catalog/schemas/{schemaName}/tables/{tableName}` | getTableByName | Full table info including columns |
| 10 | DELETE | `/v1/catalog/schemas/{schemaName}/tables/{tableName}` | dropTable | `DROP TABLE lake.{schema}.{name}` via DuckDB |
| 11 | GET | `/v1/catalog/schemas/{schemaName}/tables/{tableName}/columns` | listTableColumns | Column list by schema/table name |
| 12 | GET | `/v1/metastore/summary` | getMetastoreSummary | DuckLake metastore info (data_path, counts) |

### SKIP (with rationale)

| UC Category | Reason |
|---|---|
| **Volumes** | DuckLake has no volume abstraction; S3 paths are internal per-table |
| **Functions** | DuckDB UDFs are session-scoped, not persisted in DuckLake metastore |
| **RegisteredModels / ModelVersions** | ML model registry, unrelated to DuckLake |
| **TemporaryCredentials** | Already covered by `/v1/manifest` (presigned URLs with RLS) |
| **UC-style Permissions** | Existing `/v1/grants` system is more expressive; no need to duplicate |
| **Credentials / External Locations** | Single S3 backend via env vars; no multi-storage management needed |
| **DeltaCommits** | DuckLake uses its own snapshot model, not Delta format |
| **Staging Tables** | DuckLake handles staging internally |
| **Multi-catalog CRUD** | System is single-catalog (`lake`); exposing read-only info is sufficient |

## Key Design Decisions

1. **Single catalog**: Hardcode catalog name `"lake"`. Paths use `/v1/catalog/...` (singular). Multi-catalog would be a `/v2` breaking change.

2. **Catalog endpoints bypass SecureEngine**: They execute constructed DDL directly on the DuckDB `*sql.DB` via `CatalogRepository`. Authorization is checked at the service layer using existing `AuthorizationService.CheckPrivilege()` with `CREATE_TABLE`/`CREATE_SCHEMA` privilege constants (already defined in `domain/grant.go`). The SecureEngine DDL block stays in place for user-submitted SQL via `/query`.

3. **Custom metadata table**: DuckLake's internal `ducklake_schema`/`ducklake_table` don't store `comment`, `properties`, or `owner`. A new `catalog_metadata` SQLite table stores these UC-expected fields. The service layer joins DuckLake metastore data with custom metadata for responses.

4. **Pagination**: Use `page_token` + `max_results` params (UC-compatible API surface). Internally, `page_token` is base64-encoded offset. All list endpoints (existing + new) get pagination. Responses wrapped in `{data: [...], next_page_token: "..."}`.

5. **Identifier safety**: Schema/table names from API requests must be validated (alphanumeric + underscore) and properly quoted before constructing DDL SQL.

6. **Deprecate old introspection**: Mark `/v1/schemas`, `/v1/schemas/{id}/tables`, `/v1/tables/{id}/columns` as deprecated in OpenAPI spec but keep functional.

---

## Phase 1: Pagination Infrastructure

**Goal**: Add pagination to all existing list endpoints + define shared pagination types.

### 1.1 New domain types
- **`internal/domain/pagination.go`** (new): `PageRequest{MaxResults int, PageToken string}`, `PageResponse` struct, `DecodePageToken()`/`EncodePageToken()` helpers (base64 offset encoding)

### 1.2 OpenAPI spec changes (`internal/api/openapi.yaml`)
- Add shared `max_results` and `page_token` query parameter definitions under `components/parameters`
- Add paginated wrapper schemas: `PaginatedPrincipals`, `PaginatedGroups`, `PaginatedGroupMembers`, `PaginatedGrants`, `PaginatedRowFilters`, `PaginatedColumnMasks`, `PaginatedSchemas`, `PaginatedTables`, `PaginatedColumns`
- Update all 10 list endpoint responses from bare arrays to paginated wrappers
- Migrate `AuditLogResponse` from `limit/offset` to `page_token/max_results` style

### 1.3 Repository changes (add `LIMIT ? OFFSET ?` + count queries)
- **`internal/domain/repository.go`**: Update signatures: `List(ctx, page PageRequest) ([]T, int64, error)` for all list methods
- **`internal/db/repository/principal.go`**: Update `List()` 
- **`internal/db/repository/group.go`**: Update `List()`, `ListMembers()`
- **`internal/db/repository/grant.go`**: Update `ListForPrincipal()`, `ListForSecurable()`
- **`internal/db/repository/row_filter.go`**: Update `GetForTable()`
- **`internal/db/repository/column_mask.go`**: Update `GetForTable()`
- **`internal/db/repository/introspection.go`**: Update `ListSchemas()`, `ListTables()`, `ListColumns()`
- **`internal/db/repository/audit.go`**: Migrate to `PageRequest` params

### 1.4 Service layer updates (pass-through pagination)
- **`internal/service/principal.go`**, **`group.go`**, **`grant.go`**, **`row_filter.go`**, **`column_mask.go`**, **`introspection.go`**, **`audit.go`**: Update method signatures

### 1.5 Handler updates (`internal/api/handler.go`)
- Update all list handlers to parse `max_results`/`page_token`, call service with `PageRequest`, return paginated envelope

### 1.6 Code generation
```bash
oapi-codegen -config internal/api/types.cfg.yaml internal/api/openapi.yaml
oapi-codegen -config internal/api/server.cfg.yaml internal/api/openapi.yaml
```

### 1.7 Test updates (`internal/api/handler_test.go`)
- Update `TestAPI_ListPrincipals` and other list tests to expect paginated response format

**Breaking change**: All list responses change from `[...]` to `{data: [...], next_page_token: "..."}`. This is acceptable since we're making the API production-ready.

---

## Phase 2: Catalog Info + Schema CRUD

**Goal**: Add schema management endpoints and catalog info.

### 2.1 New migration
- **`internal/db/migrations/009_create_catalog_metadata.sql`** (new):
  ```sql
  CREATE TABLE catalog_metadata (
      securable_type TEXT NOT NULL,  -- 'schema' or 'table'
      securable_name TEXT NOT NULL,  -- 'main' or 'main.titanic'
      comment TEXT,
      properties TEXT,               -- JSON key-value map
      owner TEXT,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now')),
      UNIQUE(securable_type, securable_name)
  );
  ```

### 2.2 New domain types
- **`internal/domain/catalog.go`** (new):
  - `CatalogInfo{Name, Comment, Properties, CreatedAt, UpdatedAt}`
  - `SchemaDetail{Name, CatalogName, Comment, Properties, Owner, SchemaID, CreatedAt, UpdatedAt}` (richer than existing `Schema`)
  - `TableDetail{Name, SchemaName, CatalogName, TableType, Columns []ColumnDetail, Comment, Properties, Owner, TableID, CreatedAt, UpdatedAt}`
  - `ColumnDetail{Name, Type, Position, Nullable, Comment}`
  - `CreateSchemaRequest{Name, Comment, Properties}`
  - `UpdateSchemaRequest{Comment, Properties}`
  - `CreateTableRequest{Name, Columns []CreateColumnDef, Comment}`
  - `CreateColumnDef{Name, Type}`
  - `MetastoreSummary{CatalogName, MetastoreType, StorageBackend, DataPath, SchemaCount, TableCount}`

### 2.3 New repository interface (add to `internal/domain/repository.go`)
```go
type CatalogRepository interface {
    GetCatalogInfo(ctx context.Context) (*CatalogInfo, error)
    GetMetastoreSummary(ctx context.Context) (*MetastoreSummary, error)
    CreateSchema(ctx context.Context, name, comment, owner string) (*SchemaDetail, error)
    GetSchema(ctx context.Context, name string) (*SchemaDetail, error)
    ListSchemas(ctx context.Context, page PageRequest) ([]SchemaDetail, int64, error)
    UpdateSchema(ctx context.Context, name string, comment *string, props map[string]string) (*SchemaDetail, error)
    DeleteSchema(ctx context.Context, name string, force bool) error
    CreateTable(ctx context.Context, schemaName string, req CreateTableRequest, owner string) (*TableDetail, error)
    GetTable(ctx context.Context, schemaName, tableName string) (*TableDetail, error)
    ListTables(ctx context.Context, schemaName string, page PageRequest) ([]TableDetail, int64, error)
    DeleteTable(ctx context.Context, schemaName, tableName string) error
    ListColumns(ctx context.Context, schemaName, tableName string, page PageRequest) ([]ColumnDetail, int64, error)
}
```

### 2.4 New repository implementation
- **`internal/db/repository/catalog.go`** (new): `CatalogRepo{metaDB, duckDB *sql.DB}`
  - DDL ops (Create/Delete Schema/Table) execute on `duckDB`, then read-back from `metaDB` (DuckLake's SQLite tables)
  - Read ops query `ducklake_schema`/`ducklake_table`/`ducklake_column` from `metaDB`, left-joining with `catalog_metadata` for comment/properties/owner
  - Includes `validateIdentifier()` to prevent SQL injection in DDL construction

### 2.5 New service
- **`internal/service/catalog.go`** (new): `CatalogService{repo, auth, audit}`
  - Authorization enforcement: `CreateSchema` checks `CREATE_SCHEMA` on catalog (ID=0), `CreateTable` checks `CREATE_TABLE` on target schema, `DeleteSchema/DeleteTable` checks ownership or admin
  - Audit logging for all mutating operations
  - Input validation (name length, format)

### 2.6 OpenAPI spec additions (`internal/api/openapi.yaml`)
- New schemas: `CatalogInfo`, `SchemaDetail`, `TableDetail`, `ColumnDetail`, `CreateSchemaRequest`, `UpdateSchemaRequest`, `CreateTableRequest`, `CreateColumnDef`, `MetastoreSummary`
- New paths: `/catalog`, `/catalog/schemas`, `/catalog/schemas/{schemaName}`, `/catalog/schemas/{schemaName}/tables`, `/catalog/schemas/{schemaName}/tables/{tableName}`, `/catalog/schemas/{schemaName}/tables/{tableName}/columns`, `/metastore/summary`
- Mark old `/schemas`, `/schemas/{id}/tables`, `/tables/{id}/columns` as deprecated

### 2.7 Handler additions (`internal/api/handler.go`)
- Add `catalog *service.CatalogService` to `APIHandler` struct and `NewHandler` constructor
- Implement 12 new strict-server interface methods
- Add mapping helpers: `schemaDetailToAPI()`, `tableDetailToAPI()`, `columnDetailToAPI()`

### 2.8 Code generation + test updates

---

## Phase 3: Tests (COMPLETED + NEW)

### 3A: Mock handler tests — COMPLETED

All handler-level tests using `mockCatalogRepo` are implemented and passing in `internal/api/handler_test.go` and `internal/api/mock_catalog_test.go`. These cover HTTP routing, authorization, validation, pagination, and error codes. A pre-existing `groups_table` bug was also fixed in `internal/db/repository/group.go`.

### 3B: Repo-layer integration tests with real local DuckLake — TO IMPLEMENT

**Goal**: Validate that `CatalogRepo` DDL + metastore read-back works against a real DuckLake-attached DuckDB using local filesystem storage (no S3, no credentials).

**Location**: `test/integration/catalog_test.go` — follows the existing pattern (`//go:build integration`, same package `integration`).

**Approach**: Create a `setupLocalDuckLake(t)` helper in `test/integration/helpers_test.go` that:
1. Opens an in-memory DuckDB (`sql.Open("duckdb", "")`)
2. Installs + loads `ducklake` and `sqlite` extensions (`INSTALL ducklake; LOAD ducklake; INSTALL sqlite; LOAD sqlite;`)
3. Creates a temp dir for metadata SQLite + data files
4. Attaches DuckLake with local storage: `ATTACH 'ducklake:sqlite:<tmpDir>/meta.sqlite' AS lake (DATA_PATH '<tmpDir>/lake_data/')`
5. Runs `USE lake`
6. Opens the same SQLite file independently for metaDB reads
7. Runs app migrations on metaDB (for `catalog_metadata` table)
8. Returns `(duckDB, metaDB)` pair — ready for `repository.NewCatalogRepo(metaDB, duckDB)`

**Prerequisite check**: The helper should `t.Skip` if `INSTALL ducklake` fails (e.g. no internet, extension not cached). No S3, no `.env`, no extension binary needed.

**New file**: `test/integration/catalog_test.go` with these table-driven tests:

1. **`TestCatalog_SchemaCRUD`** — Sequential lifecycle steps:
   - `CreateSchema("analytics", "test schema", "admin")` → verify name, catalogName, schemaID > 0
   - `GetSchema("analytics")` → verify matches created
   - `ListSchemas(PageRequest{})` → contains "analytics" + "main" (DuckLake auto-creates "main")
   - `UpdateSchema("analytics", &"updated", props)` → verify comment/properties updated
   - `DeleteSchema("analytics", false)` → success
   - `GetSchema("analytics")` → NotFoundError

2. **`TestCatalog_TableCRUD`** — Sequential lifecycle:
   - `CreateSchema("test_schema", ...)` first
   - `CreateTable("test_schema", {Name:"users", Columns:[{id,INTEGER},{name,VARCHAR}]}, "admin")` → verify name, columns, schemaName, tableType="MANAGED"
   - `GetTable("test_schema", "users")` → verify columns returned with correct types
   - `ListTables("test_schema", PageRequest{})` → contains "users"
   - `ListColumns("test_schema", "users", PageRequest{})` → 2 columns, correct names/types/positions
   - `DeleteTable("test_schema", "users")` → success
   - `GetTable("test_schema", "users")` → NotFoundError

3. **`TestCatalog_SchemaConflict`** — Table-driven error cases:
   - Create same schema twice → ConflictError
   - Create table in nonexistent schema → NotFoundError
   - Delete nonexistent schema → NotFoundError
   - Create table with invalid name → ValidationError

4. **`TestCatalog_CascadeDelete`** —
   - Create schema + table in it
   - `DeleteSchema("s", false)` → ConflictError (not empty)
   - `DeleteSchema("s", true)` → success (cascade)
   - `GetTable("s", "t")` → NotFoundError (table gone too)

5. **`TestCatalog_MetastoreSummary`** —
   - Get summary before/after creating schemas+tables
   - Verify SchemaCount and TableCount change

6. **`TestCatalog_Pagination`** —
   - Create 5 schemas
   - `ListSchemas(PageRequest{MaxResults: 2})` → 2 results, total >= 5
   - Walk pages with NextPageToken until exhausted, verify all schema names collected

**Helper addition to `helpers_test.go`**:

```go
func setupLocalDuckLake(t *testing.T) (*sql.DB, *sql.DB) {
    t.Helper()
    tmpDir := t.TempDir()
    metaPath := filepath.Join(tmpDir, "meta.sqlite")
    dataPath := filepath.Join(tmpDir, "lake_data") + "/"
    os.MkdirAll(dataPath, 0o755)

    duckDB, err := sql.Open("duckdb", "")
    if err != nil { t.Fatalf("open duckdb: %v", err) }
    t.Cleanup(func() { duckDB.Close() })

    // Install and load DuckLake extension (skip if unavailable)
    for _, stmt := range []string{
        "INSTALL ducklake", "LOAD ducklake",
        "INSTALL sqlite",  "LOAD sqlite",
    } {
        if _, err := duckDB.Exec(stmt); err != nil {
            t.Skipf("%s failed (extension not available): %v", stmt, err)
        }
    }

    attachSQL := fmt.Sprintf(
        `ATTACH 'ducklake:sqlite:%s' AS lake (DATA_PATH '%s')`,
        metaPath, dataPath,
    )
    if _, err := duckDB.Exec(attachSQL); err != nil {
        t.Fatalf("attach ducklake: %v", err)
    }
    if _, err := duckDB.Exec("USE lake"); err != nil {
        t.Fatalf("use lake: %v", err)
    }

    // Open same SQLite for metaDB reads (CatalogRepo pattern)
    metaDB, err := sql.Open("sqlite3", metaPath+"?_foreign_keys=on&mode=ro")
    if err != nil { t.Fatalf("open sqlite: %v", err) }
    t.Cleanup(func() { metaDB.Close() })

    // Run app migrations for catalog_metadata table
    // Need a writable connection for migrations
    metaDBRW, err := sql.Open("sqlite3", metaPath+"?_foreign_keys=on")
    if err != nil { t.Fatalf("open sqlite rw: %v", err) }
    defer metaDBRW.Close()
    if err := internaldb.RunMigrations(metaDBRW); err != nil {
        t.Fatalf("migrations: %v", err)
    }

    return duckDB, metaDB
}
```

Note: metaDB is opened read-only (`mode=ro`) since `CatalogRepo` only reads DuckLake tables from it, and writes to `catalog_metadata` which it does via `metaDB` (needs write). Actually, looking at the code, `CatalogRepo.metaDB` is used for both reads AND writes to `catalog_metadata`. So metaDB must be opened read-write. Corrected:

```go
    metaDB, err := sql.Open("sqlite3", metaPath+"?_foreign_keys=on")
```

And we run migrations directly on metaDB (no separate RW connection needed).

### Files to Create/Modify

| File | Action | Description |
|---|---|---|
| `test/integration/helpers_test.go` | **MODIFY** | Add `setupLocalDuckLake(t)` helper (~30 lines) |
| `test/integration/catalog_test.go` | **CREATE** | 6 table-driven test functions testing CatalogRepo against real local DuckLake |

### Verification

```bash
# Unit tests (fast, no external deps)
go test ./internal/... -count=1

# Integration tests (needs DuckLake extension, downloads on first run)
go test -tags integration ./test/integration/ -v -count=1 -timeout 120s
```

### What this catches that mocks cannot

| Bug | Mock | Real DuckLake |
|-----|:----:|:-------------:|
| DDL syntax errors (`CREATE SCHEMA lake."name"`) | No | Yes |
| DuckLake metastore column names/types | No | Yes |
| `ducklake_column` read-back after DDL | No | Yes |
| `DROP SCHEMA CASCADE` behavior | Simplified | Real |
| Schema IDs assigned by DuckLake | No | Yes |
| SQLite concurrent read during DuckDB write | No | Yes |

---

## Files Summary

### New files (5)
| File | Purpose |
|---|---|
| `internal/domain/pagination.go` | PageRequest, PageResponse, token helpers |
| `internal/domain/catalog.go` | CatalogInfo, SchemaDetail, TableDetail, CreateTableRequest, etc. |
| `internal/db/repository/catalog.go` | CatalogRepo impl (metaDB + duckDB) |
| `internal/service/catalog.go` | CatalogService (auth + audit + repo delegation) |
| `internal/db/migrations/009_create_catalog_metadata.sql` | Custom metadata table |

### Modified files (~18)
| File | Changes |
|---|---|
| `internal/api/openapi.yaml` | 12 new endpoints, paginated wrappers, shared params, deprecations |
| `internal/api/server.gen.go` | Regenerated |
| `internal/api/types.gen.go` | Regenerated |
| `internal/api/handler.go` | New catalog handler methods, pagination on all list handlers |
| `internal/api/handler_test.go` | Updated for pagination format, new catalog tests |
| `internal/domain/repository.go` | CatalogRepository interface, paginated signatures on existing interfaces |
| `internal/db/repository/principal.go` | Paginated List() |
| `internal/db/repository/group.go` | Paginated List(), ListMembers() |
| `internal/db/repository/grant.go` | Paginated ListForPrincipal(), ListForSecurable() |
| `internal/db/repository/row_filter.go` | Paginated GetForTable() |
| `internal/db/repository/column_mask.go` | Paginated GetForTable() |
| `internal/db/repository/introspection.go` | Paginated ListSchemas(), ListTables(), ListColumns() |
| `internal/db/repository/audit.go` | Migrate to PageRequest |
| `internal/service/principal.go` | Pass-through pagination |
| `internal/service/group.go` | Pass-through pagination |
| `internal/service/grant.go` | Pass-through pagination |
| `internal/service/row_filter.go` | Pass-through pagination |
| `internal/service/column_mask.go` | Pass-through pagination |
| `internal/service/introspection.go` | Pass-through pagination |
| `internal/service/audit.go` | Migrate to PageRequest |

### Unchanged
| File | Reason |
|---|---|
| `internal/engine/engine.go` | DDL block stays; catalog endpoints bypass SecureEngine |
| `internal/sqlrewrite/` | No changes needed |
| `internal/middleware/auth.go` | No changes needed |
| `internal/service/manifest.go` | Orthogonal to catalog CRUD |

---

## Verification

1. **Unit tests**: `go test ./internal/...` - all existing + new tests pass
2. **Integration tests**: Full lifecycle test for schema CRUD and table CRUD
3. **Build**: `go build ./...` compiles cleanly after codegen
4. **Manual smoke test**: 
   - `POST /v1/catalog/schemas` with `{"name": "test_schema"}` -> 201
   - `GET /v1/catalog/schemas` -> paginated list including "test_schema" and "main"
   - `POST /v1/catalog/schemas/test_schema/tables` with columns -> 201
   - `GET /v1/catalog/schemas/test_schema/tables/{name}` -> table detail with columns
   - `GET /v1/principals?max_results=2` -> paginated response with `next_page_token`
   - `DELETE /v1/catalog/schemas/test_schema/tables/{name}` -> 200
   - `DELETE /v1/catalog/schemas/test_schema` -> 200

## Risk Notes

- **Breaking change**: All list endpoints change from bare arrays to paginated objects. Acceptable for production-readiness.
- **DDL SQL injection**: Mitigated by `validateIdentifier()` in CatalogRepo.
- **DuckDB single-writer**: Concurrent DDL may contend. DuckDB's internal locking handles this, but error messages may be opaque.
- **DuckLake metastore read-after-write**: After DDL on duckDB, read-back from metaDB may need a small delay or same-connection read. Test to confirm.
